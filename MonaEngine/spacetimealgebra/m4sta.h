/*
Gaigen 2.5 Test Suite
*/
/*
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

*/

/*! \mainpage m4sta documentation
 *
 * m4sta implementation generated by Gaigen 2.5. 
 * 
 * 
 * License: 
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  
 * 
 * \section intro_sec Introduction
 *
 * Todo
 * 
 */
#ifndef _M4STA_H_
#define _M4STA_H_

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <string>
#include <time.h> /* used to seed random generator */
namespace m4sta {

// group: 1
#define GROUP_0 1
// group: g0, g1, g2, g3
#define GROUP_1 2
// group: g0^g1, g0^g2, g0^g3, g1^g2, g1^g3, g2^g3
#define GROUP_2 4
// group: g1^g2^g3, g0^g1^g2, g0^g1^g3, g0^g2^g3
#define GROUP_3 8
// group: g0^g1^g2^g3
#define GROUP_4 16
#define GRADE_0 1
#define GRADE_1 2
#define GRADE_2 4
#define GRADE_3 8
#define GRADE_4 16


/// The dimension of the space:
extern const int m4sta_spaceDim;

/// Number of groups/grades of coordinates in a multivector:
extern const int m4sta_nbGroups;

/// The constants for the groups in an array:
extern const int m4sta_groups[];

/// The constants for the grades in an array:
extern const int m4sta_grades[];

/// Is the metric of the space Euclidean? (false or true)
extern const bool m4sta_metricEuclidean;

/// This array can be used to lookup the number of coordinates for a group part of a general multivector
extern const int m4sta_groupSize[5];

/// This array can be used to lookup the number of coordinates based on a group usage bitmap
extern const int m4sta_mvSize[32];

/// This array of ASCIIZ strings contains the names of the basis vectors
extern const char *m4sta_basisVectorNames[4];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'what basis vectors are in the basis element at position [x]?
extern const int m4sta_basisElements[16][5];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate at index [x]'?
extern const double m4sta_basisElementSignByIndex[16];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate of bitmap [x]'?
extern const double m4sta_basisElementSignByBitmap[16];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'at what index do I find basis element [x] (x = basis vector bitmap)?'
extern const int m4sta_basisElementIndexByBitmap[16];

/// This array of integers contains the indices of basis elements in the general multivector
/// Use it to answer: 'what basis element do I find at index [x]'?
extern const int m4sta_basisElementBitmapByIndex[16];

/// This array of grade of each basis elements in the general multivector
/// Use it to answer: 'what is the grade of basis element bitmap [x]'?
extern const int m4sta_basisElementGradeByBitmap[16];

/// This array of group of each basis elements in the general multivector
/// Use it to answer: 'what is the group of basis element bitmap [x]'?
extern const int m4sta_basisElementGroupByBitmap[16];
class mv;
class vector;
class g0_t;
class g1_t;
class g2_t;
class g3_t;
class I_t;
class om;

/**
This function alters the formatting of 'string()'.
'format' = NULL will give you back the default.
*/
void setStringFormat(const char *what, const char *format);

extern const char *string_fp; /* = \"%2.2f\" */
extern const char *string_start; /* = \"\" */
extern const char *string_end; /* = \"\" */
extern const char *string_mul; /* = \"*\" */
extern const char *string_wedge; /* = \"^\" */
extern const char *string_plus; /* = \" + \" */
extern const char *string_minus; /* = \" - \" */

const char *c_str(const mv &obj, char *str, int maxLength, const char *fp = NULL);
std::string toString(const mv &obj, const char *fp = NULL);

inline const char *c_str_f(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%f");}
inline const char *c_str_e(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%e");}
inline const char *c_str_e20(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%2.20e");}

inline std::string toString_f(const mv &obj) {return toString(obj, "%f");}
inline std::string toString_e(const mv &obj) {return toString(obj, "%e");}
inline std::string toString_e20(const mv &obj) {return toString(obj, "%2.20e");}




/// This class can hold a general multivector.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 5 coordinate groups:
/// group 0:1  (grade 0).
/// group 1:g0, g1, g2, g3  (grade 1).
/// group 2:g0^g1, g0^g2, g0^g3, g1^g2, g1^g3, g2^g3  (grade 2).
/// group 3:g1^g2^g3, g0^g1^g2, g0^g1^g3, g0^g2^g3  (grade 3).
/// group 4:g0^g1^g2^g3  (grade 4).
/// 
/// 
class mv
{

public:
	/// group/grade usage (a bitmap which specifies which groups/grades are stored in 'c', below).
	int m_gu; 
	/// the coordinates (array is allocated using realloc())
	double *m_c; 
public:

	/// Floating point type used by mv 
	typedef double Float;

	/// Constructs a new mv with value 0.
	inline mv()  : m_c(NULL), m_gu(0) {set();}

	/// Copy constructor.
	inline mv(const mv&A)  : m_c(NULL), m_gu(0) {set(A);}


	/// Constructs a new mv with scalar value 'scalar'.
	inline mv(double scalar)  : m_c(NULL), m_gu(0) {set(scalar);}

	/// Constructs a new mv from compressed 'coordinates'.
	/// \param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
	/// \param coordinates compressed coordinates.
	inline mv(int gu, const double *coordinates)  : m_c(NULL), m_gu(0) {set(gu, coordinates);}

	/// Converts a vector to a mv.
	inline mv(const vector&A)  : m_c(NULL), m_gu(0) {set(A);}
	/// Converts a g0_t to a mv.
	inline mv(const g0_t&A)  : m_c(NULL), m_gu(0) {set(A);}
	/// Converts a g1_t to a mv.
	inline mv(const g1_t&A)  : m_c(NULL), m_gu(0) {set(A);}
	/// Converts a g2_t to a mv.
	inline mv(const g2_t&A)  : m_c(NULL), m_gu(0) {set(A);}
	/// Converts a g3_t to a mv.
	inline mv(const g3_t&A)  : m_c(NULL), m_gu(0) {set(A);}
	/// Converts a I_t to a mv.
	inline mv(const I_t&A)  : m_c(NULL), m_gu(0) {set(A);}

	/// Destructor (frees dynamically allocated memory).
	~mv() {if (m_c != NULL) free(m_c);}

	/// Assignment operator (mv).
	inline mv &operator=(const mv &A) {if (this != &A) {set(A);} return *this;}
	/// Assignment operator (double).
	inline mv &operator=(const double &scalar) {set(scalar); return *this;}
	
	
	/// Assignment operator (mv).
	inline mv &operator=(const vector &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const g0_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const g1_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const g2_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const g3_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const I_t &A) {set(A); return *this;}

	/// Sets this mv to 0.
	void set();

	/// Copies the value of 'A' to this.
	void set(const mv &A);

	
	/// Sets this mv to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this mv from compressed 'coordinates'.
	/// \param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
	/// \param coordinates compressed coordinates.
	void set(int gu, const double *coordinates);
	
	/// Sets this mv to the value of vector A
	void set(const vector &A);
	/// Sets this mv to the value of g0_t A
	void set(const g0_t &A);
	/// Sets this mv to the value of g1_t A
	void set(const g1_t &A);
	/// Sets this mv to the value of g2_t A
	void set(const g2_t &A);
	/// Sets this mv to the value of g3_t A
	void set(const g3_t &A);
	/// Sets this mv to the value of I_t A
	void set(const I_t &A);
	/// Returns the scalar coordinate of this mv.
	inline double get_scalar() const {
		return (m_gu & 1) ? m_c[m4sta_mvSize[m_gu & 0] + 0] : 0.0;
	}
	/// Returns the g0 coordinate of this mv.
	inline double get_g0() const {
		return (m_gu & 2) ? m_c[m4sta_mvSize[m_gu & 1] + 0] : 0.0;
	}
	/// Returns the g1 coordinate of this mv.
	inline double get_g1() const {
		return (m_gu & 2) ? m_c[m4sta_mvSize[m_gu & 1] + 1] : 0.0;
	}
	/// Returns the g2 coordinate of this mv.
	inline double get_g2() const {
		return (m_gu & 2) ? m_c[m4sta_mvSize[m_gu & 1] + 2] : 0.0;
	}
	/// Returns the g3 coordinate of this mv.
	inline double get_g3() const {
		return (m_gu & 2) ? m_c[m4sta_mvSize[m_gu & 1] + 3] : 0.0;
	}
	/// Returns the g0_g1 coordinate of this mv.
	inline double get_g0_g1() const {
		return (m_gu & 4) ? m_c[m4sta_mvSize[m_gu & 3] + 0] : 0.0;
	}
	/// Returns the g0_g2 coordinate of this mv.
	inline double get_g0_g2() const {
		return (m_gu & 4) ? m_c[m4sta_mvSize[m_gu & 3] + 1] : 0.0;
	}
	/// Returns the g0_g3 coordinate of this mv.
	inline double get_g0_g3() const {
		return (m_gu & 4) ? m_c[m4sta_mvSize[m_gu & 3] + 2] : 0.0;
	}
	/// Returns the g1_g2 coordinate of this mv.
	inline double get_g1_g2() const {
		return (m_gu & 4) ? m_c[m4sta_mvSize[m_gu & 3] + 3] : 0.0;
	}
	/// Returns the g1_g3 coordinate of this mv.
	inline double get_g1_g3() const {
		return (m_gu & 4) ? m_c[m4sta_mvSize[m_gu & 3] + 4] : 0.0;
	}
	/// Returns the g2_g3 coordinate of this mv.
	inline double get_g2_g3() const {
		return (m_gu & 4) ? m_c[m4sta_mvSize[m_gu & 3] + 5] : 0.0;
	}
	/// Returns the g1_g2_g3 coordinate of this mv.
	inline double get_g1_g2_g3() const {
		return (m_gu & 8) ? m_c[m4sta_mvSize[m_gu & 7] + 0] : 0.0;
	}
	/// Returns the g0_g1_g2 coordinate of this mv.
	inline double get_g0_g1_g2() const {
		return (m_gu & 8) ? m_c[m4sta_mvSize[m_gu & 7] + 1] : 0.0;
	}
	/// Returns the g0_g1_g3 coordinate of this mv.
	inline double get_g0_g1_g3() const {
		return (m_gu & 8) ? m_c[m4sta_mvSize[m_gu & 7] + 2] : 0.0;
	}
	/// Returns the g0_g2_g3 coordinate of this mv.
	inline double get_g0_g2_g3() const {
		return (m_gu & 8) ? m_c[m4sta_mvSize[m_gu & 7] + 3] : 0.0;
	}
	/// Returns the g0_g1_g2_g3 coordinate of this mv.
	inline double get_g0_g1_g2_g3() const {
		return (m_gu & 16) ? m_c[m4sta_mvSize[m_gu & 15] + 0] : 0.0;
	}
	/// Returns array of compressed coordinates.
	inline const double *getC() const { return m_c;}
	/// Sets the scalar coordinate of this mv.
	inline void set_scalar(double val)  {
		reserveGroup_0();
		m_c[m4sta_mvSize[m_gu & 0] + 0] = val;
	}
	/// Sets the g0 coordinate of this mv.
	inline void set_g0(double val)  {
		reserveGroup_1();
		m_c[m4sta_mvSize[m_gu & 1] + 0] = val;
	}
	/// Sets the g1 coordinate of this mv.
	inline void set_g1(double val)  {
		reserveGroup_1();
		m_c[m4sta_mvSize[m_gu & 1] + 1] = val;
	}
	/// Sets the g2 coordinate of this mv.
	inline void set_g2(double val)  {
		reserveGroup_1();
		m_c[m4sta_mvSize[m_gu & 1] + 2] = val;
	}
	/// Sets the g3 coordinate of this mv.
	inline void set_g3(double val)  {
		reserveGroup_1();
		m_c[m4sta_mvSize[m_gu & 1] + 3] = val;
	}
	/// Sets the g0_g1 coordinate of this mv.
	inline void set_g0_g1(double val)  {
		reserveGroup_2();
		m_c[m4sta_mvSize[m_gu & 3] + 0] = val;
	}
	/// Sets the g0_g2 coordinate of this mv.
	inline void set_g0_g2(double val)  {
		reserveGroup_2();
		m_c[m4sta_mvSize[m_gu & 3] + 1] = val;
	}
	/// Sets the g0_g3 coordinate of this mv.
	inline void set_g0_g3(double val)  {
		reserveGroup_2();
		m_c[m4sta_mvSize[m_gu & 3] + 2] = val;
	}
	/// Sets the g1_g2 coordinate of this mv.
	inline void set_g1_g2(double val)  {
		reserveGroup_2();
		m_c[m4sta_mvSize[m_gu & 3] + 3] = val;
	}
	/// Sets the g1_g3 coordinate of this mv.
	inline void set_g1_g3(double val)  {
		reserveGroup_2();
		m_c[m4sta_mvSize[m_gu & 3] + 4] = val;
	}
	/// Sets the g2_g3 coordinate of this mv.
	inline void set_g2_g3(double val)  {
		reserveGroup_2();
		m_c[m4sta_mvSize[m_gu & 3] + 5] = val;
	}
	/// Sets the g1_g2_g3 coordinate of this mv.
	inline void set_g1_g2_g3(double val)  {
		reserveGroup_3();
		m_c[m4sta_mvSize[m_gu & 7] + 0] = val;
	}
	/// Sets the g0_g1_g2 coordinate of this mv.
	inline void set_g0_g1_g2(double val)  {
		reserveGroup_3();
		m_c[m4sta_mvSize[m_gu & 7] + 1] = val;
	}
	/// Sets the g0_g1_g3 coordinate of this mv.
	inline void set_g0_g1_g3(double val)  {
		reserveGroup_3();
		m_c[m4sta_mvSize[m_gu & 7] + 2] = val;
	}
	/// Sets the g0_g2_g3 coordinate of this mv.
	inline void set_g0_g2_g3(double val)  {
		reserveGroup_3();
		m_c[m4sta_mvSize[m_gu & 7] + 3] = val;
	}
	/// Sets the g0_g1_g2_g3 coordinate of this mv.
	inline void set_g0_g1_g2_g3(double val)  {
		reserveGroup_4();
		m_c[m4sta_mvSize[m_gu & 15] + 0] = val;
	}

	/// Compresses this mv by removing groups/grades with coordinates are smaller than epsilon.
	void compress(double epsilon = 0.0);
	/// Sets each entry in 'ptrs' to a pointer to the coordinates for the respective grade / group.
	/// \param ptrs Array of pointers to grades/groups. The pointers are set by this function.
	/// \param nulls When true, pointers are set to NULL for empty grades/groups; otherwise a pointer to an array filled with zeros is used.
	void expand(const double *ptrs[5], bool nulls = true) const;

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap (in 'bm').
	double largestBasisBlade(unsigned int &bm) const;
	/// returns grade/group.
	inline int gu() const {return m_gu;}

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}
public:
	inline double const *nullFloats() const {
		static double *nf = NULL;
		return (nf == NULL) ? (nf = new double[16]) : nf;
	}

public:
	/// Set m_gu, reallocates m_c to the size required by gu
	inline void setGroupUsage(int gu) {
		if (m_gu == gu) return;
		m_gu = gu;
		int nbCoords = m4sta_mvSize[m_gu];
		if (nbCoords > 0)
			m_c = (double*)realloc(m_c, nbCoords * sizeof(double));
	}

	/**
	Allocates memory for coordinate GROUP_0.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_0() {
		if ((m_gu & 1) == 0) {
			const int groupUsageBelow = m_gu & 0;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 1;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 1;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + m4sta_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + m4sta_mvSize[groupUsageBelow];
			for (int i = m4sta_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + m4sta_mvSize[groupUsageBelow];
			ptr[0] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_1.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_1() {
		if ((m_gu & 2) == 0) {
			const int groupUsageBelow = m_gu & 1;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 2;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 3;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + m4sta_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + m4sta_mvSize[groupUsageBelow];
			for (int i = m4sta_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + m4sta_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_2.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_2() {
		if ((m_gu & 4) == 0) {
			const int groupUsageBelow = m_gu & 3;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 4;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 7;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + m4sta_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + m4sta_mvSize[groupUsageBelow];
			for (int i = m4sta_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + m4sta_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = ptr[5] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_3.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_3() {
		if ((m_gu & 8) == 0) {
			const int groupUsageBelow = m_gu & 7;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 8;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 15;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + m4sta_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + m4sta_mvSize[groupUsageBelow];
			for (int i = m4sta_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + m4sta_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_4.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_4() {
		if ((m_gu & 16) == 0) {
			const int groupUsageBelow = m_gu & 15;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 16;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 31;

			setGroupUsage(newGroupUsage);


			// set coordinates of new group to 0
			double *ptr = m_c + m4sta_mvSize[groupUsageBelow];
			ptr[0] = 0.0;
		}
	}
}; // end of class mv

/// This class can hold a specialized multivector of type vector.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate g0  (array index: G0 = 0)
///   - coordinate g1  (array index: G1 = 1)
///   - coordinate g2  (array index: G2 = 2)
///   - coordinate g3  (array index: G3 = 3)
/// 
/// The type has no constant coordinates.
/// 
/// 
class vector
{
public:
	/// The coordinates (stored in an array).
	double m_c[4]; // g0, g1, g2, g3
public:

	/// Floating point type used by vector 
	typedef double Float;
	/// Array indices of vector coordinates.
	typedef enum {
		/// index of coordinate for g0 in vector
		G0 = 0, 
		/// index of coordinate for g1 in vector
		G1 = 1, 
		/// index of coordinate for g2 in vector
		G2 = 2, 
		/// index of coordinate for g3 in vector
		G3 = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_g0_g1_g2_g3
	} CoordinateOrder;

	/// Constructs a new vector with variable coordinates set to 0.
	inline vector() {set();}

	/// Copy constructor.
	inline vector(const vector &A) {set(A);}



	/// Constructs a new vector from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline vector(mv &A, int filler) {set(A);}

	/// Constructs a new vector. Coordinate values come from 'A'.
	inline vector(const CoordinateOrder co, const double A[4]) {set(co, A);}
	
	/// Constructs a new vector with each coordinate specified.
	inline vector(const CoordinateOrder co,  double g0, double g1, double g2, double g3) {
		set(co, g0, g1, g2, g3);
	}

	/// Assignment operator (vector).
	inline vector &operator=(const vector &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline vector &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const vector &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double g0, double g1, double g2, double g3);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the g0 coordinate.
	inline double get_g0() const { return m_c[0];}
	/// Sets the g0 coordinate.
	inline void set_g0(double g0) { m_c[0] = g0;}
	/// Returns the g1 coordinate.
	inline double get_g1() const { return m_c[1];}
	/// Sets the g1 coordinate.
	inline void set_g1(double g1) { m_c[1] = g1;}
	/// Returns the g2 coordinate.
	inline double get_g2() const { return m_c[2];}
	/// Sets the g2 coordinate.
	inline void set_g2(double g2) { m_c[2] = g2;}
	/// Returns the g3 coordinate.
	inline double get_g3() const { return m_c[3];}
	/// Sets the g3 coordinate.
	inline void set_g3(double g3) { m_c[3] = g3;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
	/// Returns array of coordinates.
	inline const double *getC(CoordinateOrder) const { return m_c;}
}; // end of class vector

/// This class can hold a specialized multivector of type g0_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - g0 = 1
/// 
/// 
class g0_t
{
public:
public:

	/// Floating point type used by g0_t 
	typedef double Float;
	/// Array indices of g0_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new g0_t with variable coordinates set to 0.
	inline g0_t() {set();}

	/// Copy constructor.
	inline g0_t(const g0_t &A) {set(A);}



	/// Constructs a new g0_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline g0_t(mv &A, int filler) {set(A);}


	/// Assignment operator (g0_t).
	inline g0_t &operator=(const g0_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline g0_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const g0_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the g0 coordinate.
	inline double get_g0() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class g0_t

/// This class can hold a specialized multivector of type g1_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - g1 = 1
/// 
/// 
class g1_t
{
public:
public:

	/// Floating point type used by g1_t 
	typedef double Float;
	/// Array indices of g1_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new g1_t with variable coordinates set to 0.
	inline g1_t() {set();}

	/// Copy constructor.
	inline g1_t(const g1_t &A) {set(A);}



	/// Constructs a new g1_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline g1_t(mv &A, int filler) {set(A);}


	/// Assignment operator (g1_t).
	inline g1_t &operator=(const g1_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline g1_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const g1_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the g1 coordinate.
	inline double get_g1() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class g1_t

/// This class can hold a specialized multivector of type g2_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - g2 = 1
/// 
/// 
class g2_t
{
public:
public:

	/// Floating point type used by g2_t 
	typedef double Float;
	/// Array indices of g2_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new g2_t with variable coordinates set to 0.
	inline g2_t() {set();}

	/// Copy constructor.
	inline g2_t(const g2_t &A) {set(A);}



	/// Constructs a new g2_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline g2_t(mv &A, int filler) {set(A);}


	/// Assignment operator (g2_t).
	inline g2_t &operator=(const g2_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline g2_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const g2_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the g2 coordinate.
	inline double get_g2() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class g2_t

/// This class can hold a specialized multivector of type g3_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - g3 = 1
/// 
/// 
class g3_t
{
public:
public:

	/// Floating point type used by g3_t 
	typedef double Float;
	/// Array indices of g3_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new g3_t with variable coordinates set to 0.
	inline g3_t() {set();}

	/// Copy constructor.
	inline g3_t(const g3_t &A) {set(A);}



	/// Constructs a new g3_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline g3_t(mv &A, int filler) {set(A);}


	/// Assignment operator (g3_t).
	inline g3_t &operator=(const g3_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline g3_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const g3_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the g3 coordinate.
	inline double get_g3() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class g3_t

/// This class can hold a specialized multivector of type I_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - g0^g1^g2^g3 = 1
/// 
/// 
class I_t
{
public:
public:

	/// Floating point type used by I_t 
	typedef double Float;
	/// Array indices of I_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new I_t with variable coordinates set to 0.
	inline I_t() {set();}

	/// Copy constructor.
	inline I_t(const I_t &A) {set(A);}



	/// Constructs a new I_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline I_t(mv &A, int filler) {set(A);}


	/// Assignment operator (I_t).
	inline I_t &operator=(const I_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline I_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const I_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the g0^g1^g2^g3 coordinate.
	inline double get_g0_g1_g2_g3() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class I_t

/// This class can hold a general outermorphism.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 5 matrices, one for each grade.
/// The columns of these matrices are the range of the outermorphism.
/// Matrices are stored in row-major order. So the coordinates of rows are stored contiguously.
/// Domain grade 1: g0, g1, g2, g3.
/// Domain grade 2: g0^g1, g0^g2, g1^g2, g0^g3, g1^g3, g2^g3.
/// Domain grade 3: g0^g1^g2, g0^g1^g3, g0^g2^g3, g1^g2^g3.
/// Domain grade 4: g0^g1^g2^g3.
/// 
/// The range and domain are equal.
/// 
class om
{
public:
	/// Matrix for grade 1; the size is 4 x 4
	double m_m1[16];
	/// Matrix for grade 2; the size is 6 x 6
	double m_m2[36];
	/// Matrix for grade 3; the size is 4 x 4
	double m_m3[16];
	/// Matrix for grade 4; the size is 1 x 1
	double m_m4[1];
public:

	/// Floating point type used by om 
	typedef double Float;

	/// Constructs a new om, set to identity
	inline om() { setIdentity(); }

	/// Copy constructor.
	inline om(const om&M) { set(M); }

	/// Constructor from matrix
	inline om(const double *M) { set(M); }

	/// Constructor from images of basis vectors.
	inline om(const vector &ig0, const vector &ig1, const vector &ig2, const vector &ig3)
		{ set(ig0, ig1, ig2, ig3); }


	/// Sets this to 'M'
	inline om &operator=(const om &M) { if (this != &M) { set(M); } return *this; }


	/// Sets this om to identity.
	void setIdentity();

	/// Sets this to 'M'.
	void set(const om &M);

	/// Sets this to matrix.
	void set(const double *M);

	/// Sets this to transformation specified by the images of the basis vectors.
	void set(const vector &ig0, const vector &ig1, const vector &ig2, const vector &ig3);

	private:
	void set_0();
	void set_1();
	void set_2();
	void set_3();
	void set_grade_2_0();
	void set_grade_2_1();
	void set_grade_2_2();
	void set_grade_2_3();
	void set_grade_2_4();
	void set_grade_2_5();
	void set_grade_3_0();
	void set_grade_3_1();
	void set_grade_3_2();
	void set_grade_3_3();
	void set_grade_4_0();
	public:
}; // end of om
extern g0_t g0;
extern g1_t g1;
extern g2_t g2;
extern g3_t g3;
extern I_t I;


/**
This class is used to report usage of converted specialized multivectors.

The class is designed to be pretty safe with multi-threading without locking.
In the wordt case, some memory leaks occur and some counts are missed. 
The amount of memory leaked is bounded (goes not grow beyond a certain
point). Since the report-usage functionality is for
development/debugging only, this is not considered non-harmful.
*/
class ReportUsage {
	/// prints out error message that ReportUsage is disabled
	static void printReport(FILE *F = stdout, bool includeCount = true);
}; // end of class ReportUsage

/** Sets 1 double to zero */
void zero_1(double *dst);
/** Copies 1 double from 'src' to 'dst' */
void copy_1(double *dst, const double *src);
/** Sets 2 doubles to zero */
void zero_2(double *dst);
/** Copies 2 doubles from 'src' to 'dst' */
void copy_2(double *dst, const double *src);
/** Sets 3 doubles to zero */
void zero_3(double *dst);
/** Copies 3 doubles from 'src' to 'dst' */
void copy_3(double *dst, const double *src);
/** Sets 4 doubles to zero */
void zero_4(double *dst);
/** Copies 4 doubles from 'src' to 'dst' */
void copy_4(double *dst, const double *src);
/** Sets 5 doubles to zero */
void zero_5(double *dst);
/** Copies 5 doubles from 'src' to 'dst' */
void copy_5(double *dst, const double *src);
/** Sets 6 doubles to zero */
void zero_6(double *dst);
/** Copies 6 doubles from 'src' to 'dst' */
void copy_6(double *dst, const double *src);
/** Sets 7 doubles to zero */
void zero_7(double *dst);
/** Copies 7 doubles from 'src' to 'dst' */
void copy_7(double *dst, const double *src);
/** Sets 8 doubles to zero */
void zero_8(double *dst);
/** Copies 8 doubles from 'src' to 'dst' */
void copy_8(double *dst, const double *src);
/** Sets 9 doubles to zero */
void zero_9(double *dst);
/** Copies 9 doubles from 'src' to 'dst' */
void copy_9(double *dst, const double *src);
/** Sets 10 doubles to zero */
void zero_10(double *dst);
/** Copies 10 doubles from 'src' to 'dst' */
void copy_10(double *dst, const double *src);
/** Sets 11 doubles to zero */
void zero_11(double *dst);
/** Copies 11 doubles from 'src' to 'dst' */
void copy_11(double *dst, const double *src);
/** Sets 12 doubles to zero */
void zero_12(double *dst);
/** Copies 12 doubles from 'src' to 'dst' */
void copy_12(double *dst, const double *src);
/** Sets 13 doubles to zero */
void zero_13(double *dst);
/** Copies 13 doubles from 'src' to 'dst' */
void copy_13(double *dst, const double *src);
/** Sets 14 doubles to zero */
void zero_14(double *dst);
/** Copies 14 doubles from 'src' to 'dst' */
void copy_14(double *dst, const double *src);
/** Sets 15 doubles to zero */
void zero_15(double *dst);
/** Copies 15 doubles from 'src' to 'dst' */
void copy_15(double *dst, const double *src);
/** Sets 16 doubles to zero */
void zero_16(double *dst);
/** Copies 16 doubles from 'src' to 'dst' */
void copy_16(double *dst, const double *src);
/** Sets N doubles to zero */
void zero_N(double *dst, int N);
/** Copies N doubles from 'src' to 'dst' */
void copy_N(double *dst, const double *src, int N);
// decl SB:

/// Returns scalar part of  mv
double _double(const mv &x);
/// Returns scalar part of  mv
inline double _Float(const mv &x) {return _double(x); };

/// Compresses coordinates 'c' into a new multivector.
/// \param c the coordinates (may already be partially compressed, see argument 'gu').
/// \param epsilon value with a abs magnitude < epsilon are considered to be 0.
/// \param gu optionally specifies which groups/grades are present in 'c'.
mv mv_compress(const double *c, double epsilon = 0.0, int gu = 31);
/// Compresses an array of coordinates/basis blade bitmaps into a new multivector.
mv mv_compress(int nbBlades, const unsigned int *bitmaps, const double *coords);


/// Returns scalar part of  vector
double _double(const vector &x);
/// Returns scalar part of  vector
inline double _Float(const vector &x) {return _double(x); };
/// Returns scalar part of  g0_t
double _double(const g0_t &x);
/// Returns scalar part of  g0_t
inline double _Float(const g0_t &x) {return _double(x); };
/// Returns scalar part of  g1_t
double _double(const g1_t &x);
/// Returns scalar part of  g1_t
inline double _Float(const g1_t &x) {return _double(x); };
/// Returns scalar part of  g2_t
double _double(const g2_t &x);
/// Returns scalar part of  g2_t
inline double _Float(const g2_t &x) {return _double(x); };
/// Returns scalar part of  g3_t
double _double(const g3_t &x);
/// Returns scalar part of  g3_t
inline double _Float(const g3_t &x) {return _double(x); };
/// Returns scalar part of  I_t
double _double(const I_t &x);
/// Returns scalar part of  I_t
inline double _Float(const I_t &x) {return _double(x); };
/// Generates a random double in [0.0 1.0) interval using the c library rand() function
double genrand();
/// Seeds the random number generator for  double
void genrand_seed(unsigned int seed);
/// Seeds the random number generator for  double with the current time
void genrand_timeSeed();
/// Returns mv + mv.
mv add(const mv &a, const mv &b);
/// Returns mv - mv.
mv subtract(const mv &a, const mv &b);
/// Returns a / b
mv div(const mv &a, const double b);
/// Returns dual of mv using default metric.
mv dual(const mv &a);
/// Returns undual of mv using default metric.
mv undual(const mv &a);
/// Returns whether input multivectors are equal up to an epsilon c.
bool equals(const mv &a, const mv &b, const double c);
/// Returns grade groupBitmap of  mv.
mv extractGrade(const mv &a, int groupBitmap);
/// Returns grade 0 of  mv.
mv extractGrade0(const mv &a);
/// Returns grade 1 of  mv.
mv extractGrade1(const mv &a);
/// Returns grade 2 of  mv.
mv extractGrade2(const mv &a);
/// Returns grade 3 of  mv.
mv extractGrade3(const mv &a);
/// Returns grade 4 of  mv.
mv extractGrade4(const mv &a);
/// Returns geometric product of mv and mv.
mv gp(const mv &a, const mv &b);
/// Returns geometric product of mv and double.
mv gp_dont_mangle_1(const mv &a, const double b);
/// Returns a * versorInverse(b).
mv igp(const mv &a, const mv &b);
/// Returns a bitmap where each one-bit means that at least one coordinate of the respective grade of  a is larger than b
int gradeBitmap(const mv &a, const double b);
/// Returns (a + 1).
mv increment(const mv &a);
/// Returns (a - 1).
mv decrement(const mv &a);
/// Returns scalar product of mv and mv.
double sp(const mv &a, const mv &b);
/// Returns left contraction of mv and mv.
mv lc(const mv &a, const mv &b);
/// Returns right contraction of mv and mv.
mv rc(const mv &a, const mv &b);
/// Returns Hestenes inner product of mv and mv.
mv hip(const mv &a, const mv &b);
/// Returns Modified Hestenes inner product of mv and mv.
mv mhip(const mv &a, const mv &b);
/// Returns norm of mv using default metric.
double norm(const mv &a);
/// internal conversion function
double norm_returns_scalar(const mv &a);
/// Returns norm2 of mv using default metric.
double norm2(const mv &a);
/// internal conversion function
double norm2_returns_scalar(const mv &a);
/// Returns outer product of mv and mv.
mv op(const mv &a, const mv &b);
/// Returns double b * mv a + double c.
mv sas(const mv &a, const double b, const double c);

/** Computes exp of mv.
 */
mv exp(const mv &x, int order = 12);

/** Computes cosh of mv.
 */
mv cosh(const mv &x, int order = 12);

/** Computes sinh of mv.
 */
mv sinh(const mv &x, int order = 12);

/** Computes cos of mv.
 */
mv cos(const mv &x, int order = 12);

/** Computes sin of mv.
 */
mv sin(const mv &x, int order = 12);
/// Returns negation of mv.
mv negate(const mv &a);
/// Returns reverse of mv.
mv reverse(const mv &a);
/// Returns Clifford conjugate of mv.
mv cliffordConjugate(const mv &a);
/// Returns grade involution of mv.
mv gradeInvolution(const mv &a);
/// Returns unit of mv using default metric.
mv unit(const mv &a);
/// Returns versor inverse of a using default metric.
mv versorInverse(const mv &a);
/// Returns true if all coordinates of a are abs <= b
bool zero(const mv &a, const double b);
/// returns add(a, b)
mv operator+(const mv &a, const mv &b);
/// returns (a = add(a, b))
mv &operator+=(mv &a, const mv &b);
/// returns subtract(a, b)
mv operator-(const mv &a, const mv &b);
/// returns (a = subtract(a, b))
mv &operator-=(mv &a, const mv &b);
/// returns dual(a)
mv operator*(const mv &a);
/// returns gp(a, b)
mv operator*(const mv &a, const mv &b);
/// returns (a = gp(a, b))
mv &operator*=(mv &a, const mv &b);
/// returns igp(a, b)
mv operator/(const mv &a, const mv &b);
/// returns (a = igp(a, b))
mv &operator/=(mv &a, const mv &b);
/// returns (a = increment(a))
mv &operator++(mv &a);
/// returns (a = decrement(a))
mv &operator--(mv &a);
/// returns sp(a, b)
mv operator%(const mv &a, const mv &b);
/// returns (a = sp(a, b))
mv &operator%=(mv &a, const mv &b);
/// returns lc(a, b)
mv operator<<(const mv &a, const mv &b);
/// returns (a = lc(a, b))
mv &operator<<=(mv &a, const mv &b);
/// returns rc(a, b)
mv operator>>(const mv &a, const mv &b);
/// returns (a = rc(a, b))
mv &operator>>=(mv &a, const mv &b);
/// returns op(a, b)
mv operator^(const mv &a, const mv &b);
/// returns (a = op(a, b))
mv &operator^=(mv &a, const mv &b);
/// returns negate(a)
mv operator-(const mv &a);
/// returns reverse(a)
mv operator~(const mv &a);
/// returns versorInverse(a)
mv operator!(const mv &a);

inline void zero_1(double *dst) {
	dst[0]=0.0;
}
inline void copy_1(double *dst, const double *src) {
	dst[0] = src[0];
}
inline void zero_2(double *dst) {
	dst[0]=dst[1]=0.0;
}
inline void copy_2(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
}
inline void zero_3(double *dst) {
	dst[0]=dst[1]=dst[2]=0.0;
}
inline void copy_3(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
}
inline void zero_4(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=0.0;
}
inline void copy_4(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
}
inline void zero_5(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=0.0;
}
inline void copy_5(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
}
inline void zero_6(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=0.0;
}
inline void copy_6(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
}
inline void zero_7(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=0.0;
}
inline void copy_7(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
}
inline void zero_8(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=0.0;
}
inline void copy_8(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
}
inline void zero_9(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=0.0;
}
inline void copy_9(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
}
inline void zero_10(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=0.0;
}
inline void copy_10(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
}
inline void zero_11(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=0.0;
}
inline void copy_11(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
}
inline void zero_12(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=0.0;
}
inline void copy_12(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
}
inline void zero_13(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=0.0;
}
inline void copy_13(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
}
inline void zero_14(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=0.0;
}
inline void copy_14(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
}
inline void zero_15(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=dst[14]=0.0;
}
inline void copy_15(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
	dst[14] = src[14];
}
inline void zero_16(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=dst[14]=dst[15]=0.0;
}
inline void copy_16(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
	dst[14] = src[14];
	dst[15] = src[15];
}
/** Sets N doubles to zero */
inline void zero_N(double *dst, int N) {
	int i = 0;
	while ((N-i) > 16) {
		zero_16(dst + i);
		i += 16;
	}
	for (; i < N; i++)
		dst[i] = 0.0;
}
/** Copies N doubles from 'src' to 'dst' */
inline void copy_N(double *dst, const double *src, int N) {
	int i = 0;
	while ((N-i) > 16) {
		copy_16(dst + i, src + i);
		i += 16;
	}
	for (; i < N; i++)
		dst[i] = src[i];
}
// inline def SB:


/** structure used by custom parser */
struct m4staParseMultivectorData {
	/** the parsed value */
	mv value;
	/** this string will contain an error message when error is true */
	char message[256];
};

/** 
Parses 'str' (output of toString_mv()) and stores result in 'val' 
Throws std::string on error.
*/
mv parse(const std::string &str);

/** 
Parses 'str' (output of toString_mv()) and stores result in 'data'. 
'strSourceName' is the name of the source of 'str' (for example, a filename).
It is used for error messages.

	Returns true when 'str' parsed correctly.
Otherwise a lexer or parser error occured and you can check 
the errors in 'data->message'.
*/
bool parseEx(struct m4staParseMultivectorData &data, const std::string &str, const std::string &strSourceName);
} // end of namespace m4sta
#endif /* _M4STA_H_ */
