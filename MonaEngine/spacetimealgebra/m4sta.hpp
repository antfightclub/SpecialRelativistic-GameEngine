/*

    Licensed under the  MIT license; see LICENSE file for full details.
    Copyright (c) 2014 Mike Boyle
  
*/

/*! \mainpage m4sta documentation
 *
 * m4sta implementation generated by Gaigen 2.5. 
 * 
 * 
 * License: 

    Licensed under the  MIT license; see LICENSE file for full details.
    Copyright (c) 2014 Mike Boyle
    
 * 
 * \section intro_sec Introduction
 *
 * Todo
 * 
 */
#ifndef _M4STA_H_
#define _M4STA_H_

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <string>
namespace m4sta {

// group: 1
#define GROUP_0 1
// group: g0, g1, g2, g3
#define GROUP_1 2
// group: g0^g1, g0^g2, g1^g2, g0^g3, g1^g3, g2^g3
#define GROUP_2 4
// group: g0^g1^g2, g0^g1^g3, g0^g2^g3, g1^g2^g3
#define GROUP_3 8
// group: g0^g1^g2^g3
#define GROUP_4 16
#define GRADE_0 1
#define GRADE_1 2
#define GRADE_2 4
#define GRADE_3 8
#define GRADE_4 16


/// The dimension of the space:
extern const int m4sta_spaceDim;

/// Number of groups/grades of coordinates in a multivector:
extern const int m4sta_nbGroups;

/// The constants for the groups in an array:
extern const int m4sta_groups[];

/// The constants for the grades in an array:
extern const int m4sta_grades[];

/// Is the metric of the space Euclidean? (false or true)
extern const bool m4sta_metricEuclidean;

/// This array can be used to lookup the number of coordinates for a group part of a general multivector
extern const int m4sta_groupSize[5];

/// This array can be used to lookup the number of coordinates based on a group usage bitmap
extern const int m4sta_mvSize[32];

/// This array of ASCIIZ strings contains the names of the basis vectors
extern const char *m4sta_basisVectorNames[4];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'what basis vectors are in the basis element at position [x]?
extern const int m4sta_basisElements[16][5];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate at index [x]'?
extern const double m4sta_basisElementSignByIndex[16];

/// This array of integers contains the 'sign' (even/odd permutation of canonical order) of basis elements in the general multivector
/// Use it to answer 'what is the permutation of the coordinate of bitmap [x]'?
extern const double m4sta_basisElementSignByBitmap[16];

/// This array of integers contains the order of basis elements in the general multivector
/// Use it to answer: 'at what index do I find basis element [x] (x = basis vector bitmap)?'
extern const int m4sta_basisElementIndexByBitmap[16];

/// This array of integers contains the indices of basis elements in the general multivector
/// Use it to answer: 'what basis element do I find at index [x]'?
extern const int m4sta_basisElementBitmapByIndex[16];

/// This array of grade of each basis elements in the general multivector
/// Use it to answer: 'what is the grade of basis element bitmap [x]'?
extern const int m4sta_basisElementGradeByBitmap[16];

/// This array of group of each basis elements in the general multivector
/// Use it to answer: 'what is the group of basis element bitmap [x]'?
extern const int m4sta_basisElementGroupByBitmap[16];
class mv;
class g0_t;
class g1_t;
class g2_t;
class g3_t;
class I_t;
class I3_t;
class mv3;
class vector;
class vector3;
class bivector;
class bivector3;
class pseudovector;
class spinor;
class spinor3;

/**
This function alters the formatting of 'string()'.
'format' = NULL will give you back the default.
*/
void setStringFormat(const char *what, const char *format);

extern const char *string_fp; /* = \"%2.2f\" */
extern const char *string_start; /* = \"\" */
extern const char *string_end; /* = \"\" */
extern const char *string_mul; /* = \"*\" */
extern const char *string_wedge; /* = \"^\" */
extern const char *string_plus; /* = \" + \" */
extern const char *string_minus; /* = \" - \" */

const char *c_str(const mv &obj, char *str, int maxLength, const char *fp = NULL);
std::string toString(const mv &obj, const char *fp = NULL);

inline const char *c_str_f(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%f");}
inline const char *c_str_e(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%e");}
inline const char *c_str_e20(const mv &obj, char *str, int maxLength) {return c_str(obj, str, maxLength, "%2.20e");}

inline std::string toString_f(const mv &obj) {return toString(obj, "%f");}
inline std::string toString_e(const mv &obj) {return toString(obj, "%e");}
inline std::string toString_e20(const mv &obj) {return toString(obj, "%2.20e");}




/// This class can hold a general multivector.
/// 
/// The coordinates are stored in type double.
/// 
/// There are 5 coordinate groups:
/// group 0:1  (grade 0).
/// group 1:g0, g1, g2, g3  (grade 1).
/// group 2:g0^g1, g0^g2, g1^g2, g0^g3, g1^g3, g2^g3  (grade 2).
/// group 3:g0^g1^g2, g0^g1^g3, g0^g2^g3, g1^g2^g3  (grade 3).
/// group 4:g0^g1^g2^g3  (grade 4).
/// 
/// 16 doubles are allocated inside the struct.
/// 
class mv
{

public:
	/// group/grade usage (a bitmap which specifies which groups/grades are stored in 'c', below).
	int m_gu; 
	/// the coordinates
	double m_c[16]; 
public:

	/// Floating point type used by mv 
	typedef double Float;

	/// Constructs a new mv with value 0.
	inline mv()  {set();}

	/// Copy constructor.
	inline mv(const mv&A)  {set(A);}


	/// Constructs a new mv with scalar value 'scalar'.
	inline mv(double scalar)  {set(scalar);}

	/// Constructs a new mv from compressed 'coordinates'.
	/// \param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
	/// \param coordinates compressed coordinates.
	inline mv(int gu, const double *coordinates)  {set(gu, coordinates);}

	/// Converts a g0_t to a mv.
	inline mv(const g0_t&A)  {set(A);}
	/// Converts a g1_t to a mv.
	inline mv(const g1_t&A)  {set(A);}
	/// Converts a g2_t to a mv.
	inline mv(const g2_t&A)  {set(A);}
	/// Converts a g3_t to a mv.
	inline mv(const g3_t&A)  {set(A);}
	/// Converts a I_t to a mv.
	inline mv(const I_t&A)  {set(A);}
	/// Converts a I3_t to a mv.
	inline mv(const I3_t&A)  {set(A);}
	/// Converts a mv3 to a mv.
	inline mv(const mv3&A)  {set(A);}
	/// Converts a vector to a mv.
	inline mv(const vector&A)  {set(A);}
	/// Converts a vector3 to a mv.
	inline mv(const vector3&A)  {set(A);}
	/// Converts a bivector to a mv.
	inline mv(const bivector&A)  {set(A);}
	/// Converts a bivector3 to a mv.
	inline mv(const bivector3&A)  {set(A);}
	/// Converts a pseudovector to a mv.
	inline mv(const pseudovector&A)  {set(A);}
	/// Converts a spinor to a mv.
	inline mv(const spinor&A)  {set(A);}
	/// Converts a spinor3 to a mv.
	inline mv(const spinor3&A)  {set(A);}


	/// Assignment operator (mv).
	inline mv &operator=(const mv &A) {if (this != &A) {set(A);} return *this;}
	/// Assignment operator (double).
	inline mv &operator=(const double &scalar) {set(scalar); return *this;}
	
	
	/// Assignment operator (mv).
	inline mv &operator=(const g0_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const g1_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const g2_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const g3_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const I_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const I3_t &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const mv3 &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const vector &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const vector3 &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const bivector &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const bivector3 &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const pseudovector &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const spinor &A) {set(A); return *this;}
	/// Assignment operator (mv).
	inline mv &operator=(const spinor3 &A) {set(A); return *this;}

	/// Sets this mv to 0.
	void set();

	/// Copies the value of 'A' to this.
	void set(const mv &A);

	
	/// Sets this mv to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this mv from compressed 'coordinates'.
	/// \param gu bitwise OR of the GRADEs or GROUPs that are non-zero.
	/// \param coordinates compressed coordinates.
	void set(int gu, const double *coordinates);
	
	/// Sets this mv to the value of g0_t A
	void set(const g0_t &A);
	/// Sets this mv to the value of g1_t A
	void set(const g1_t &A);
	/// Sets this mv to the value of g2_t A
	void set(const g2_t &A);
	/// Sets this mv to the value of g3_t A
	void set(const g3_t &A);
	/// Sets this mv to the value of I_t A
	void set(const I_t &A);
	/// Sets this mv to the value of I3_t A
	void set(const I3_t &A);
	/// Sets this mv to the value of mv3 A
	void set(const mv3 &A);
	/// Sets this mv to the value of vector A
	void set(const vector &A);
	/// Sets this mv to the value of vector3 A
	void set(const vector3 &A);
	/// Sets this mv to the value of bivector A
	void set(const bivector &A);
	/// Sets this mv to the value of bivector3 A
	void set(const bivector3 &A);
	/// Sets this mv to the value of pseudovector A
	void set(const pseudovector &A);
	/// Sets this mv to the value of spinor A
	void set(const spinor &A);
	/// Sets this mv to the value of spinor3 A
	void set(const spinor3 &A);
	/// Returns the scalar coordinate of this mv.
	inline double get_scalar() const {
		return (m_gu & 1) ? m_c[m4sta_mvSize[m_gu & 0] + 0] : 0.0;
	}
	/// Returns the g0 coordinate of this mv.
	inline double get_g0() const {
		return (m_gu & 2) ? m_c[m4sta_mvSize[m_gu & 1] + 0] : 0.0;
	}
	/// Returns the g1 coordinate of this mv.
	inline double get_g1() const {
		return (m_gu & 2) ? m_c[m4sta_mvSize[m_gu & 1] + 1] : 0.0;
	}
	/// Returns the g2 coordinate of this mv.
	inline double get_g2() const {
		return (m_gu & 2) ? m_c[m4sta_mvSize[m_gu & 1] + 2] : 0.0;
	}
	/// Returns the g3 coordinate of this mv.
	inline double get_g3() const {
		return (m_gu & 2) ? m_c[m4sta_mvSize[m_gu & 1] + 3] : 0.0;
	}
	/// Returns the g0_g1 coordinate of this mv.
	inline double get_g0_g1() const {
		return (m_gu & 4) ? m_c[m4sta_mvSize[m_gu & 3] + 0] : 0.0;
	}
	/// Returns the g0_g2 coordinate of this mv.
	inline double get_g0_g2() const {
		return (m_gu & 4) ? m_c[m4sta_mvSize[m_gu & 3] + 1] : 0.0;
	}
	/// Returns the g1_g2 coordinate of this mv.
	inline double get_g1_g2() const {
		return (m_gu & 4) ? m_c[m4sta_mvSize[m_gu & 3] + 2] : 0.0;
	}
	/// Returns the g0_g3 coordinate of this mv.
	inline double get_g0_g3() const {
		return (m_gu & 4) ? m_c[m4sta_mvSize[m_gu & 3] + 3] : 0.0;
	}
	/// Returns the g1_g3 coordinate of this mv.
	inline double get_g1_g3() const {
		return (m_gu & 4) ? m_c[m4sta_mvSize[m_gu & 3] + 4] : 0.0;
	}
	/// Returns the g2_g3 coordinate of this mv.
	inline double get_g2_g3() const {
		return (m_gu & 4) ? m_c[m4sta_mvSize[m_gu & 3] + 5] : 0.0;
	}
	/// Returns the g0_g1_g2 coordinate of this mv.
	inline double get_g0_g1_g2() const {
		return (m_gu & 8) ? m_c[m4sta_mvSize[m_gu & 7] + 0] : 0.0;
	}
	/// Returns the g0_g1_g3 coordinate of this mv.
	inline double get_g0_g1_g3() const {
		return (m_gu & 8) ? m_c[m4sta_mvSize[m_gu & 7] + 1] : 0.0;
	}
	/// Returns the g0_g2_g3 coordinate of this mv.
	inline double get_g0_g2_g3() const {
		return (m_gu & 8) ? m_c[m4sta_mvSize[m_gu & 7] + 2] : 0.0;
	}
	/// Returns the g1_g2_g3 coordinate of this mv.
	inline double get_g1_g2_g3() const {
		return (m_gu & 8) ? m_c[m4sta_mvSize[m_gu & 7] + 3] : 0.0;
	}
	/// Returns the g0_g1_g2_g3 coordinate of this mv.
	inline double get_g0_g1_g2_g3() const {
		return (m_gu & 16) ? m_c[m4sta_mvSize[m_gu & 15] + 0] : 0.0;
	}
	/// Returns array of compressed coordinates.
	inline const double *getC() const { return m_c;}
	/// Sets the scalar coordinate of this mv.
	inline void set_scalar(double val)  {
		reserveGroup_0();
		m_c[m4sta_mvSize[m_gu & 0] + 0] = val;
	}
	/// Sets the g0 coordinate of this mv.
	inline void set_g0(double val)  {
		reserveGroup_1();
		m_c[m4sta_mvSize[m_gu & 1] + 0] = val;
	}
	/// Sets the g1 coordinate of this mv.
	inline void set_g1(double val)  {
		reserveGroup_1();
		m_c[m4sta_mvSize[m_gu & 1] + 1] = val;
	}
	/// Sets the g2 coordinate of this mv.
	inline void set_g2(double val)  {
		reserveGroup_1();
		m_c[m4sta_mvSize[m_gu & 1] + 2] = val;
	}
	/// Sets the g3 coordinate of this mv.
	inline void set_g3(double val)  {
		reserveGroup_1();
		m_c[m4sta_mvSize[m_gu & 1] + 3] = val;
	}
	/// Sets the g0_g1 coordinate of this mv.
	inline void set_g0_g1(double val)  {
		reserveGroup_2();
		m_c[m4sta_mvSize[m_gu & 3] + 0] = val;
	}
	/// Sets the g0_g2 coordinate of this mv.
	inline void set_g0_g2(double val)  {
		reserveGroup_2();
		m_c[m4sta_mvSize[m_gu & 3] + 1] = val;
	}
	/// Sets the g1_g2 coordinate of this mv.
	inline void set_g1_g2(double val)  {
		reserveGroup_2();
		m_c[m4sta_mvSize[m_gu & 3] + 2] = val;
	}
	/// Sets the g0_g3 coordinate of this mv.
	inline void set_g0_g3(double val)  {
		reserveGroup_2();
		m_c[m4sta_mvSize[m_gu & 3] + 3] = val;
	}
	/// Sets the g1_g3 coordinate of this mv.
	inline void set_g1_g3(double val)  {
		reserveGroup_2();
		m_c[m4sta_mvSize[m_gu & 3] + 4] = val;
	}
	/// Sets the g2_g3 coordinate of this mv.
	inline void set_g2_g3(double val)  {
		reserveGroup_2();
		m_c[m4sta_mvSize[m_gu & 3] + 5] = val;
	}
	/// Sets the g0_g1_g2 coordinate of this mv.
	inline void set_g0_g1_g2(double val)  {
		reserveGroup_3();
		m_c[m4sta_mvSize[m_gu & 7] + 0] = val;
	}
	/// Sets the g0_g1_g3 coordinate of this mv.
	inline void set_g0_g1_g3(double val)  {
		reserveGroup_3();
		m_c[m4sta_mvSize[m_gu & 7] + 1] = val;
	}
	/// Sets the g0_g2_g3 coordinate of this mv.
	inline void set_g0_g2_g3(double val)  {
		reserveGroup_3();
		m_c[m4sta_mvSize[m_gu & 7] + 2] = val;
	}
	/// Sets the g1_g2_g3 coordinate of this mv.
	inline void set_g1_g2_g3(double val)  {
		reserveGroup_3();
		m_c[m4sta_mvSize[m_gu & 7] + 3] = val;
	}
	/// Sets the g0_g1_g2_g3 coordinate of this mv.
	inline void set_g0_g1_g2_g3(double val)  {
		reserveGroup_4();
		m_c[m4sta_mvSize[m_gu & 15] + 0] = val;
	}

	/// Compresses this mv by removing groups/grades with coordinates are smaller than epsilon.
	void compress(double epsilon = 0.0);
	/// Sets each entry in 'ptrs' to a pointer to the coordinates for the respective grade / group.
	/// \param ptrs Array of pointers to grades/groups. The pointers are set by this function.
	/// \param nulls When true, pointers are set to NULL for empty grades/groups; otherwise a pointer to an array filled with zeros is used.
	void expand(const double *ptrs[5], bool nulls = true) const;

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap (in 'bm').
	double largestBasisBlade(unsigned int &bm) const;
	/// returns grade/group.
	inline int gu() const {return m_gu;}

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}
public:
	inline double const *nullFloats() const {
		static double *nf = NULL;
		return (nf == NULL) ? (nf = new double[16]) : nf;
	}

public:
	/// Set m_gu, reallocates m_c to the size required by gu
	inline void setGroupUsage(int gu) {
		if (m_gu == gu) return;
		m_gu = gu;
	}

	/**
	Allocates memory for coordinate GROUP_0.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_0() {
		if ((m_gu & 1) == 0) {
			const int groupUsageBelow = m_gu & 0;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 1;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 1;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + m4sta_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + m4sta_mvSize[groupUsageBelow];
			for (int i = m4sta_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + m4sta_mvSize[groupUsageBelow];
			ptr[0] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_1.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_1() {
		if ((m_gu & 2) == 0) {
			const int groupUsageBelow = m_gu & 1;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 2;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 3;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + m4sta_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + m4sta_mvSize[groupUsageBelow];
			for (int i = m4sta_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + m4sta_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_2.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_2() {
		if ((m_gu & 4) == 0) {
			const int groupUsageBelow = m_gu & 3;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 4;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 7;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + m4sta_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + m4sta_mvSize[groupUsageBelow];
			for (int i = m4sta_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + m4sta_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = ptr[4] = ptr[5] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_3.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_3() {
		if ((m_gu & 8) == 0) {
			const int groupUsageBelow = m_gu & 7;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 8;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 15;

			setGroupUsage(newGroupUsage);

			// move coordinate beyond new group
			double *dst = m_c + m4sta_mvSize[newGroupUsageBelowNextGroup];
			double *src = m_c + m4sta_mvSize[groupUsageBelow];
			for (int i = m4sta_mvSize[groupUsageAbove]-1; i >= 0; i--) // work from end to start of array to avoid overwriting (dst is always beyond src)
				dst[i] = src[i];

			// set coordinates of new group to 0
			double *ptr = m_c + m4sta_mvSize[groupUsageBelow];
			ptr[0] = ptr[1] = ptr[2] = ptr[3] = 0.0;
		}
	}
	/**
	Allocates memory for coordinate GROUP_4.
	If the group is already present, nothing changes.
	If the group is not present, memory is allocated for the new group,
	and the coordinates for the group are set to zero.
	*/
	inline void reserveGroup_4() {
		if ((m_gu & 16) == 0) {
			const int groupUsageBelow = m_gu & 15;
			const int groupUsageAbove = m_gu ^ groupUsageBelow;
			const int newGroupUsage = m_gu | 16;
			const int newGroupUsageBelowNextGroup = newGroupUsage & 31;

			setGroupUsage(newGroupUsage);


			// set coordinates of new group to 0
			double *ptr = m_c + m4sta_mvSize[groupUsageBelow];
			ptr[0] = 0.0;
		}
	}
}; // end of class mv

/// This class can hold a specialized multivector of type g0_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - g0 = 1
/// 
/// 
class g0_t
{
public:
public:

	/// Floating point type used by g0_t 
	typedef double Float;
	/// Array indices of g0_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new g0_t with variable coordinates set to 0.
	inline g0_t() {set();}

	/// Copy constructor.
	inline g0_t(const g0_t &A) {set(A);}



	/// Constructs a new g0_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline g0_t(mv &A, int filler) {set(A);}


	/// Assignment operator (g0_t).
	inline g0_t &operator=(const g0_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline g0_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const g0_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the g0 coordinate.
	inline double get_g0() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class g0_t

/// This class can hold a specialized multivector of type g1_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - g1 = 1
/// 
/// 
class g1_t
{
public:
public:

	/// Floating point type used by g1_t 
	typedef double Float;
	/// Array indices of g1_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new g1_t with variable coordinates set to 0.
	inline g1_t() {set();}

	/// Copy constructor.
	inline g1_t(const g1_t &A) {set(A);}



	/// Constructs a new g1_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline g1_t(mv &A, int filler) {set(A);}


	/// Assignment operator (g1_t).
	inline g1_t &operator=(const g1_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline g1_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const g1_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the g1 coordinate.
	inline double get_g1() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class g1_t

/// This class can hold a specialized multivector of type g2_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - g2 = 1
/// 
/// 
class g2_t
{
public:
public:

	/// Floating point type used by g2_t 
	typedef double Float;
	/// Array indices of g2_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new g2_t with variable coordinates set to 0.
	inline g2_t() {set();}

	/// Copy constructor.
	inline g2_t(const g2_t &A) {set(A);}



	/// Constructs a new g2_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline g2_t(mv &A, int filler) {set(A);}


	/// Assignment operator (g2_t).
	inline g2_t &operator=(const g2_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline g2_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const g2_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the g2 coordinate.
	inline double get_g2() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class g2_t

/// This class can hold a specialized multivector of type g3_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - g3 = 1
/// 
/// 
class g3_t
{
public:
public:

	/// Floating point type used by g3_t 
	typedef double Float;
	/// Array indices of g3_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new g3_t with variable coordinates set to 0.
	inline g3_t() {set();}

	/// Copy constructor.
	inline g3_t(const g3_t &A) {set(A);}



	/// Constructs a new g3_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline g3_t(mv &A, int filler) {set(A);}


	/// Assignment operator (g3_t).
	inline g3_t &operator=(const g3_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline g3_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const g3_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the g3 coordinate.
	inline double get_g3() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class g3_t

/// This class can hold a specialized multivector of type I_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - g0^g1^g2^g3 = 1
/// 
/// 
class I_t
{
public:
public:

	/// Floating point type used by I_t 
	typedef double Float;
	/// Array indices of I_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new I_t with variable coordinates set to 0.
	inline I_t() {set();}

	/// Copy constructor.
	inline I_t(const I_t &A) {set(A);}



	/// Constructs a new I_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline I_t(mv &A, int filler) {set(A);}


	/// Assignment operator (I_t).
	inline I_t &operator=(const I_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline I_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const I_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the g0^g1^g2^g3 coordinate.
	inline double get_g0_g1_g2_g3() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class I_t

/// This class can hold a specialized multivector of type I3_t.
/// 
/// The coordinates are stored in type double.
/// 
/// The type is constant.
/// 
/// The constant non-zero coordinates are:
///   - g1^g2^g3 = 1
/// 
/// 
class I3_t
{
public:
public:

	/// Floating point type used by I3_t 
	typedef double Float;
	/// Array indices of I3_t coordinates.
	typedef enum {
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord
	} CoordinateOrder;

	/// Constructs a new I3_t with variable coordinates set to 0.
	inline I3_t() {set();}

	/// Copy constructor.
	inline I3_t(const I3_t &A) {set(A);}



	/// Constructs a new I3_t from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline I3_t(mv &A, int filler) {set(A);}


	/// Assignment operator (I3_t).
	inline I3_t &operator=(const I3_t &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline I3_t &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	inline void set() {}
	/// Sets this to 'A'.
	void set(const I3_t &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);



	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the g1^g2^g3 coordinate.
	inline double get_g1_g2_g3() const { return 1.0;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
}; // end of class I3_t

/// This class can hold a specialized multivector of type mv3.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate 1  (array index: SCALAR = 0)
///   - coordinate g1  (array index: G1 = 1)
///   - coordinate g2  (array index: G2 = 2)
///   - coordinate g3  (array index: G3 = 3)
///   - coordinate g1^g2  (array index: G1_G2 = 4)
///   - coordinate g1^g3  (array index: G1_G3 = 5)
///   - coordinate g2^g3  (array index: G2_G3 = 6)
///   - coordinate g1^g2^g3  (array index: G1_G2_G3 = 7)
/// 
/// The type has no constant coordinates.
/// 
/// 
class mv3
{
public:
	/// The coordinates (stored in an array).
	double m_c[8]; // 1, g1, g2, g3, g1^g2, g1^g3, g2^g3, g1^g2^g3
public:

	/// Floating point type used by mv3 
	typedef double Float;
	/// Array indices of mv3 coordinates.
	typedef enum {
		/// index of coordinate for 1 in mv3
		SCALAR = 0, 
		/// index of coordinate for g1 in mv3
		G1 = 1, 
		/// index of coordinate for g2 in mv3
		G2 = 2, 
		/// index of coordinate for g3 in mv3
		G3 = 3, 
		/// index of coordinate for g1^g2 in mv3
		G1_G2 = 4, 
		/// index of coordinate for g1^g3 in mv3
		G1_G3 = 5, 
		/// index of coordinate for g2^g3 in mv3
		G2_G3 = 6, 
		/// index of coordinate for g1^g2^g3 in mv3
		G1_G2_G3 = 7, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_scalar_g1_g2_g3_g1g2_g1g3_g2g3_g1g2g3
	} CoordinateOrder;

	/// Constructs a new mv3 with variable coordinates set to 0.
	inline mv3() {set();}

	/// Copy constructor.
	inline mv3(const mv3 &A) {set(A);}


	/// Constructs a new mv3 with scalar value 'scalar'.
	inline mv3(double scalar) {set(scalar);}

	/// Constructs a new mv3 from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline mv3(mv &A, int filler) {set(A);}

	/// Constructs a new mv3. Coordinate values come from 'A'.
	inline mv3(const CoordinateOrder co, const double A[8]) {set(co, A);}
	
	/// Constructs a new mv3 with each coordinate specified.
	inline mv3(const CoordinateOrder co,  double scalar, double g1, double g2, double g3, double g1_g2, double g1_g3, double g2_g3, double g1_g2_g3) {
		set(co, scalar, g1, g2, g3, g1_g2, g1_g3, g2_g3, g1_g2_g3);
	}

	/// Assignment operator (mv3).
	inline mv3 &operator=(const mv3 &A) {if (this != &A) {set(A);} return *this;}
	
		
	/// Assignment operator (double).
	inline mv3 &operator=(const double &scalar) {set(scalar); return *this;}

	/// Assignment operator (mv).
	inline mv3 &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const mv3 &A);

	/// Sets this to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[8]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double scalar, double g1, double g2, double g3, double g1_g2, double g1_g3, double g2_g3, double g1_g2_g3);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the 1 coordinate.
	inline double get_scalar() const { return m_c[0];}
	/// Sets the 1 coordinate.
	inline void set_scalar(double scalar) { m_c[0] = scalar;}
	/// Returns the g1 coordinate.
	inline double get_g1() const { return m_c[1];}
	/// Sets the g1 coordinate.
	inline void set_g1(double g1) { m_c[1] = g1;}
	/// Returns the g2 coordinate.
	inline double get_g2() const { return m_c[2];}
	/// Sets the g2 coordinate.
	inline void set_g2(double g2) { m_c[2] = g2;}
	/// Returns the g3 coordinate.
	inline double get_g3() const { return m_c[3];}
	/// Sets the g3 coordinate.
	inline void set_g3(double g3) { m_c[3] = g3;}
	/// Returns the g1^g2 coordinate.
	inline double get_g1_g2() const { return m_c[4];}
	/// Sets the g1^g2 coordinate.
	inline void set_g1_g2(double g1_g2) { m_c[4] = g1_g2;}
	/// Returns the g1^g3 coordinate.
	inline double get_g1_g3() const { return m_c[5];}
	/// Sets the g1^g3 coordinate.
	inline void set_g1_g3(double g1_g3) { m_c[5] = g1_g3;}
	/// Returns the g2^g3 coordinate.
	inline double get_g2_g3() const { return m_c[6];}
	/// Sets the g2^g3 coordinate.
	inline void set_g2_g3(double g2_g3) { m_c[6] = g2_g3;}
	/// Returns the g1^g2^g3 coordinate.
	inline double get_g1_g2_g3() const { return m_c[7];}
	/// Sets the g1^g2^g3 coordinate.
	inline void set_g1_g2_g3(double g1_g2_g3) { m_c[7] = g1_g2_g3;}
	/// Returns array of coordinates.
	inline const double *getC(CoordinateOrder) const { return m_c;}
}; // end of class mv3

/// This class can hold a specialized multivector of type vector.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate g0  (array index: G0 = 0)
///   - coordinate g1  (array index: G1 = 1)
///   - coordinate g2  (array index: G2 = 2)
///   - coordinate g3  (array index: G3 = 3)
/// 
/// The type has no constant coordinates.
/// 
/// 
class vector
{
public:
	/// The coordinates (stored in an array).
	double m_c[4]; // g0, g1, g2, g3
public:

	/// Floating point type used by vector 
	typedef double Float;
	/// Array indices of vector coordinates.
	typedef enum {
		/// index of coordinate for g0 in vector
		G0 = 0, 
		/// index of coordinate for g1 in vector
		G1 = 1, 
		/// index of coordinate for g2 in vector
		G2 = 2, 
		/// index of coordinate for g3 in vector
		G3 = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_g0_g1_g2_g3
	} CoordinateOrder;

	/// Constructs a new vector with variable coordinates set to 0.
	inline vector() {set();}

	/// Copy constructor.
	inline vector(const vector &A) {set(A);}



	/// Constructs a new vector from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline vector(mv &A, int filler) {set(A);}

	/// Constructs a new vector. Coordinate values come from 'A'.
	inline vector(const CoordinateOrder co, const double A[4]) {set(co, A);}
	
	/// Constructs a new vector with each coordinate specified.
	inline vector(const CoordinateOrder co,  double g0, double g1, double g2, double g3) {
		set(co, g0, g1, g2, g3);
	}

	/// Assignment operator (vector).
	inline vector &operator=(const vector &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline vector &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const vector &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double g0, double g1, double g2, double g3);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the g0 coordinate.
	inline double get_g0() const { return m_c[0];}
	/// Sets the g0 coordinate.
	inline void set_g0(double g0) { m_c[0] = g0;}
	/// Returns the g1 coordinate.
	inline double get_g1() const { return m_c[1];}
	/// Sets the g1 coordinate.
	inline void set_g1(double g1) { m_c[1] = g1;}
	/// Returns the g2 coordinate.
	inline double get_g2() const { return m_c[2];}
	/// Sets the g2 coordinate.
	inline void set_g2(double g2) { m_c[2] = g2;}
	/// Returns the g3 coordinate.
	inline double get_g3() const { return m_c[3];}
	/// Sets the g3 coordinate.
	inline void set_g3(double g3) { m_c[3] = g3;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
	/// Returns array of coordinates.
	inline const double *getC(CoordinateOrder) const { return m_c;}
}; // end of class vector

/// This class can hold a specialized multivector of type vector3.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate g1  (array index: G1 = 0)
///   - coordinate g2  (array index: G2 = 1)
///   - coordinate g3  (array index: G3 = 2)
/// 
/// The type has no constant coordinates.
/// 
/// 
class vector3
{
public:
	/// The coordinates (stored in an array).
	double m_c[3]; // g1, g2, g3
public:

	/// Floating point type used by vector3 
	typedef double Float;
	/// Array indices of vector3 coordinates.
	typedef enum {
		/// index of coordinate for g1 in vector3
		G1 = 0, 
		/// index of coordinate for g2 in vector3
		G2 = 1, 
		/// index of coordinate for g3 in vector3
		G3 = 2, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_g1_g2_g3
	} CoordinateOrder;

	/// Constructs a new vector3 with variable coordinates set to 0.
	inline vector3() {set();}

	/// Copy constructor.
	inline vector3(const vector3 &A) {set(A);}



	/// Constructs a new vector3 from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline vector3(mv &A, int filler) {set(A);}

	/// Constructs a new vector3. Coordinate values come from 'A'.
	inline vector3(const CoordinateOrder co, const double A[3]) {set(co, A);}
	
	/// Constructs a new vector3 with each coordinate specified.
	inline vector3(const CoordinateOrder co,  double g1, double g2, double g3) {
		set(co, g1, g2, g3);
	}

	/// Assignment operator (vector3).
	inline vector3 &operator=(const vector3 &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline vector3 &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const vector3 &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[3]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double g1, double g2, double g3);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the g1 coordinate.
	inline double get_g1() const { return m_c[0];}
	/// Sets the g1 coordinate.
	inline void set_g1(double g1) { m_c[0] = g1;}
	/// Returns the g2 coordinate.
	inline double get_g2() const { return m_c[1];}
	/// Sets the g2 coordinate.
	inline void set_g2(double g2) { m_c[1] = g2;}
	/// Returns the g3 coordinate.
	inline double get_g3() const { return m_c[2];}
	/// Sets the g3 coordinate.
	inline void set_g3(double g3) { m_c[2] = g3;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
	/// Returns array of coordinates.
	inline const double *getC(CoordinateOrder) const { return m_c;}
}; // end of class vector3

/// This class can hold a specialized multivector of type bivector.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate g0^g1  (array index: G0_G1 = 0)
///   - coordinate g0^g2  (array index: G0_G2 = 1)
///   - coordinate g0^g3  (array index: G0_G3 = 2)
///   - coordinate g1^g2  (array index: G1_G2 = 3)
///   - coordinate g1^g3  (array index: G1_G3 = 4)
///   - coordinate g2^g3  (array index: G2_G3 = 5)
/// 
/// The type has no constant coordinates.
/// 
/// 
class bivector
{
public:
	/// The coordinates (stored in an array).
	double m_c[6]; // g0^g1, g0^g2, g0^g3, g1^g2, g1^g3, g2^g3
public:

	/// Floating point type used by bivector 
	typedef double Float;
	/// Array indices of bivector coordinates.
	typedef enum {
		/// index of coordinate for g0^g1 in bivector
		G0_G1 = 0, 
		/// index of coordinate for g0^g2 in bivector
		G0_G2 = 1, 
		/// index of coordinate for g0^g3 in bivector
		G0_G3 = 2, 
		/// index of coordinate for g1^g2 in bivector
		G1_G2 = 3, 
		/// index of coordinate for g1^g3 in bivector
		G1_G3 = 4, 
		/// index of coordinate for g2^g3 in bivector
		G2_G3 = 5, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3
	} CoordinateOrder;

	/// Constructs a new bivector with variable coordinates set to 0.
	inline bivector() {set();}

	/// Copy constructor.
	inline bivector(const bivector &A) {set(A);}



	/// Constructs a new bivector from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline bivector(mv &A, int filler) {set(A);}

	/// Constructs a new bivector. Coordinate values come from 'A'.
	inline bivector(const CoordinateOrder co, const double A[6]) {set(co, A);}
	
	/// Constructs a new bivector with each coordinate specified.
	inline bivector(const CoordinateOrder co,  double g0_g1, double g0_g2, double g0_g3, double g1_g2, double g1_g3, double g2_g3) {
		set(co, g0_g1, g0_g2, g0_g3, g1_g2, g1_g3, g2_g3);
	}

	/// Assignment operator (bivector).
	inline bivector &operator=(const bivector &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline bivector &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const bivector &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[6]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double g0_g1, double g0_g2, double g0_g3, double g1_g2, double g1_g3, double g2_g3);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the g0^g1 coordinate.
	inline double get_g0_g1() const { return m_c[0];}
	/// Sets the g0^g1 coordinate.
	inline void set_g0_g1(double g0_g1) { m_c[0] = g0_g1;}
	/// Returns the g0^g2 coordinate.
	inline double get_g0_g2() const { return m_c[1];}
	/// Sets the g0^g2 coordinate.
	inline void set_g0_g2(double g0_g2) { m_c[1] = g0_g2;}
	/// Returns the g0^g3 coordinate.
	inline double get_g0_g3() const { return m_c[2];}
	/// Sets the g0^g3 coordinate.
	inline void set_g0_g3(double g0_g3) { m_c[2] = g0_g3;}
	/// Returns the g1^g2 coordinate.
	inline double get_g1_g2() const { return m_c[3];}
	/// Sets the g1^g2 coordinate.
	inline void set_g1_g2(double g1_g2) { m_c[3] = g1_g2;}
	/// Returns the g1^g3 coordinate.
	inline double get_g1_g3() const { return m_c[4];}
	/// Sets the g1^g3 coordinate.
	inline void set_g1_g3(double g1_g3) { m_c[4] = g1_g3;}
	/// Returns the g2^g3 coordinate.
	inline double get_g2_g3() const { return m_c[5];}
	/// Sets the g2^g3 coordinate.
	inline void set_g2_g3(double g2_g3) { m_c[5] = g2_g3;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
	/// Returns array of coordinates.
	inline const double *getC(CoordinateOrder) const { return m_c;}
}; // end of class bivector

/// This class can hold a specialized multivector of type bivector3.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate g1^g2  (array index: G1_G2 = 0)
///   - coordinate g1^g3  (array index: G1_G3 = 1)
///   - coordinate g2^g3  (array index: G2_G3 = 2)
/// 
/// The type has no constant coordinates.
/// 
/// 
class bivector3
{
public:
	/// The coordinates (stored in an array).
	double m_c[3]; // g1^g2, g1^g3, g2^g3
public:

	/// Floating point type used by bivector3 
	typedef double Float;
	/// Array indices of bivector3 coordinates.
	typedef enum {
		/// index of coordinate for g1^g2 in bivector3
		G1_G2 = 0, 
		/// index of coordinate for g1^g3 in bivector3
		G1_G3 = 1, 
		/// index of coordinate for g2^g3 in bivector3
		G2_G3 = 2, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_g1g2_g1g3_g2g3
	} CoordinateOrder;

	/// Constructs a new bivector3 with variable coordinates set to 0.
	inline bivector3() {set();}

	/// Copy constructor.
	inline bivector3(const bivector3 &A) {set(A);}



	/// Constructs a new bivector3 from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline bivector3(mv &A, int filler) {set(A);}

	/// Constructs a new bivector3. Coordinate values come from 'A'.
	inline bivector3(const CoordinateOrder co, const double A[3]) {set(co, A);}
	
	/// Constructs a new bivector3 with each coordinate specified.
	inline bivector3(const CoordinateOrder co,  double g1_g2, double g1_g3, double g2_g3) {
		set(co, g1_g2, g1_g3, g2_g3);
	}

	/// Assignment operator (bivector3).
	inline bivector3 &operator=(const bivector3 &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline bivector3 &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const bivector3 &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[3]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double g1_g2, double g1_g3, double g2_g3);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the g1^g2 coordinate.
	inline double get_g1_g2() const { return m_c[0];}
	/// Sets the g1^g2 coordinate.
	inline void set_g1_g2(double g1_g2) { m_c[0] = g1_g2;}
	/// Returns the g1^g3 coordinate.
	inline double get_g1_g3() const { return m_c[1];}
	/// Sets the g1^g3 coordinate.
	inline void set_g1_g3(double g1_g3) { m_c[1] = g1_g3;}
	/// Returns the g2^g3 coordinate.
	inline double get_g2_g3() const { return m_c[2];}
	/// Sets the g2^g3 coordinate.
	inline void set_g2_g3(double g2_g3) { m_c[2] = g2_g3;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
	/// Returns array of coordinates.
	inline const double *getC(CoordinateOrder) const { return m_c;}
}; // end of class bivector3

/// This class can hold a specialized multivector of type pseudovector.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate g0^g1^g2  (array index: G0_G1_G2 = 0)
///   - coordinate g0^g1^g3  (array index: G0_G1_G3 = 1)
///   - coordinate g0^g2^g3  (array index: G0_G2_G3 = 2)
///   - coordinate g1^g2^g3  (array index: G1_G2_G3 = 3)
/// 
/// The type has no constant coordinates.
/// 
/// 
class pseudovector
{
public:
	/// The coordinates (stored in an array).
	double m_c[4]; // g0^g1^g2, g0^g1^g3, g0^g2^g3, g1^g2^g3
public:

	/// Floating point type used by pseudovector 
	typedef double Float;
	/// Array indices of pseudovector coordinates.
	typedef enum {
		/// index of coordinate for g0^g1^g2 in pseudovector
		G0_G1_G2 = 0, 
		/// index of coordinate for g0^g1^g3 in pseudovector
		G0_G1_G3 = 1, 
		/// index of coordinate for g0^g2^g3 in pseudovector
		G0_G2_G3 = 2, 
		/// index of coordinate for g1^g2^g3 in pseudovector
		G1_G2_G3 = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_g0g1g2_g0g1g3_g0g2g3_g1g2g3
	} CoordinateOrder;

	/// Constructs a new pseudovector with variable coordinates set to 0.
	inline pseudovector() {set();}

	/// Copy constructor.
	inline pseudovector(const pseudovector &A) {set(A);}



	/// Constructs a new pseudovector from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline pseudovector(mv &A, int filler) {set(A);}

	/// Constructs a new pseudovector. Coordinate values come from 'A'.
	inline pseudovector(const CoordinateOrder co, const double A[4]) {set(co, A);}
	
	/// Constructs a new pseudovector with each coordinate specified.
	inline pseudovector(const CoordinateOrder co,  double g0_g1_g2, double g0_g1_g3, double g0_g2_g3, double g1_g2_g3) {
		set(co, g0_g1_g2, g0_g1_g3, g0_g2_g3, g1_g2_g3);
	}

	/// Assignment operator (pseudovector).
	inline pseudovector &operator=(const pseudovector &A) {if (this != &A) {set(A);} return *this;}
	
		

	/// Assignment operator (mv).
	inline pseudovector &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const pseudovector &A);


	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double g0_g1_g2, double g0_g1_g3, double g0_g2_g3, double g1_g2_g3);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the g0^g1^g2 coordinate.
	inline double get_g0_g1_g2() const { return m_c[0];}
	/// Sets the g0^g1^g2 coordinate.
	inline void set_g0_g1_g2(double g0_g1_g2) { m_c[0] = g0_g1_g2;}
	/// Returns the g0^g1^g3 coordinate.
	inline double get_g0_g1_g3() const { return m_c[1];}
	/// Sets the g0^g1^g3 coordinate.
	inline void set_g0_g1_g3(double g0_g1_g3) { m_c[1] = g0_g1_g3;}
	/// Returns the g0^g2^g3 coordinate.
	inline double get_g0_g2_g3() const { return m_c[2];}
	/// Sets the g0^g2^g3 coordinate.
	inline void set_g0_g2_g3(double g0_g2_g3) { m_c[2] = g0_g2_g3;}
	/// Returns the g1^g2^g3 coordinate.
	inline double get_g1_g2_g3() const { return m_c[3];}
	/// Sets the g1^g2^g3 coordinate.
	inline void set_g1_g2_g3(double g1_g2_g3) { m_c[3] = g1_g2_g3;}
	/// Returns the scalar coordinate (which is always 0).
	inline double get_scalar() const { return 0.0;}
	/// Returns array of coordinates.
	inline const double *getC(CoordinateOrder) const { return m_c;}
}; // end of class pseudovector

/// This class can hold a specialized multivector of type spinor.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate 1  (array index: SCALAR = 0)
///   - coordinate g0^g1  (array index: G0_G1 = 1)
///   - coordinate g0^g2  (array index: G0_G2 = 2)
///   - coordinate g0^g3  (array index: G0_G3 = 3)
///   - coordinate g1^g2  (array index: G1_G2 = 4)
///   - coordinate g1^g3  (array index: G1_G3 = 5)
///   - coordinate g2^g3  (array index: G2_G3 = 6)
///   - coordinate g0^g1^g2^g3  (array index: G0_G1_G2_G3 = 7)
/// 
/// The type has no constant coordinates.
/// 
/// 
class spinor
{
public:
	/// The coordinates (stored in an array).
	double m_c[8]; // 1, g0^g1, g0^g2, g0^g3, g1^g2, g1^g3, g2^g3, g0^g1^g2^g3
public:

	/// Floating point type used by spinor 
	typedef double Float;
	/// Array indices of spinor coordinates.
	typedef enum {
		/// index of coordinate for 1 in spinor
		SCALAR = 0, 
		/// index of coordinate for g0^g1 in spinor
		G0_G1 = 1, 
		/// index of coordinate for g0^g2 in spinor
		G0_G2 = 2, 
		/// index of coordinate for g0^g3 in spinor
		G0_G3 = 3, 
		/// index of coordinate for g1^g2 in spinor
		G1_G2 = 4, 
		/// index of coordinate for g1^g3 in spinor
		G1_G3 = 5, 
		/// index of coordinate for g2^g3 in spinor
		G2_G3 = 6, 
		/// index of coordinate for g0^g1^g2^g3 in spinor
		G0_G1_G2_G3 = 7, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_scalar_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3_g0g1g2g3
	} CoordinateOrder;

	/// Constructs a new spinor with variable coordinates set to 0.
	inline spinor() {set();}

	/// Copy constructor.
	inline spinor(const spinor &A) {set(A);}


	/// Constructs a new spinor with scalar value 'scalar'.
	inline spinor(double scalar) {set(scalar);}

	/// Constructs a new spinor from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline spinor(mv &A, int filler) {set(A);}

	/// Constructs a new spinor. Coordinate values come from 'A'.
	inline spinor(const CoordinateOrder co, const double A[8]) {set(co, A);}
	
	/// Constructs a new spinor with each coordinate specified.
	inline spinor(const CoordinateOrder co,  double scalar, double g0_g1, double g0_g2, double g0_g3, double g1_g2, double g1_g3, double g2_g3, double g0_g1_g2_g3) {
		set(co, scalar, g0_g1, g0_g2, g0_g3, g1_g2, g1_g3, g2_g3, g0_g1_g2_g3);
	}

	/// Assignment operator (spinor).
	inline spinor &operator=(const spinor &A) {if (this != &A) {set(A);} return *this;}
	
		
	/// Assignment operator (double).
	inline spinor &operator=(const double &scalar) {set(scalar); return *this;}

	/// Assignment operator (mv).
	inline spinor &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const spinor &A);

	/// Sets this to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[8]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double scalar, double g0_g1, double g0_g2, double g0_g3, double g1_g2, double g1_g3, double g2_g3, double g0_g1_g2_g3);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the 1 coordinate.
	inline double get_scalar() const { return m_c[0];}
	/// Sets the 1 coordinate.
	inline void set_scalar(double scalar) { m_c[0] = scalar;}
	/// Returns the g0^g1 coordinate.
	inline double get_g0_g1() const { return m_c[1];}
	/// Sets the g0^g1 coordinate.
	inline void set_g0_g1(double g0_g1) { m_c[1] = g0_g1;}
	/// Returns the g0^g2 coordinate.
	inline double get_g0_g2() const { return m_c[2];}
	/// Sets the g0^g2 coordinate.
	inline void set_g0_g2(double g0_g2) { m_c[2] = g0_g2;}
	/// Returns the g0^g3 coordinate.
	inline double get_g0_g3() const { return m_c[3];}
	/// Sets the g0^g3 coordinate.
	inline void set_g0_g3(double g0_g3) { m_c[3] = g0_g3;}
	/// Returns the g1^g2 coordinate.
	inline double get_g1_g2() const { return m_c[4];}
	/// Sets the g1^g2 coordinate.
	inline void set_g1_g2(double g1_g2) { m_c[4] = g1_g2;}
	/// Returns the g1^g3 coordinate.
	inline double get_g1_g3() const { return m_c[5];}
	/// Sets the g1^g3 coordinate.
	inline void set_g1_g3(double g1_g3) { m_c[5] = g1_g3;}
	/// Returns the g2^g3 coordinate.
	inline double get_g2_g3() const { return m_c[6];}
	/// Sets the g2^g3 coordinate.
	inline void set_g2_g3(double g2_g3) { m_c[6] = g2_g3;}
	/// Returns the g0^g1^g2^g3 coordinate.
	inline double get_g0_g1_g2_g3() const { return m_c[7];}
	/// Sets the g0^g1^g2^g3 coordinate.
	inline void set_g0_g1_g2_g3(double g0_g1_g2_g3) { m_c[7] = g0_g1_g2_g3;}
	/// Returns array of coordinates.
	inline const double *getC(CoordinateOrder) const { return m_c;}
}; // end of class spinor

/// This class can hold a specialized multivector of type spinor3.
/// 
/// The coordinates are stored in type double.
/// 
/// The variable non-zero coordinates are:
///   - coordinate 1  (array index: SCALAR = 0)
///   - coordinate g1^g2  (array index: G1_G2 = 1)
///   - coordinate g1^g3  (array index: G1_G3 = 2)
///   - coordinate g2^g3  (array index: G2_G3 = 3)
/// 
/// The type has no constant coordinates.
/// 
/// 
class spinor3
{
public:
	/// The coordinates (stored in an array).
	double m_c[4]; // 1, g1^g2, g1^g3, g2^g3
public:

	/// Floating point type used by spinor3 
	typedef double Float;
	/// Array indices of spinor3 coordinates.
	typedef enum {
		/// index of coordinate for 1 in spinor3
		SCALAR = 0, 
		/// index of coordinate for g1^g2 in spinor3
		G1_G2 = 1, 
		/// index of coordinate for g1^g3 in spinor3
		G1_G3 = 2, 
		/// index of coordinate for g2^g3 in spinor3
		G2_G3 = 3, 
	} ArrayIndex;
	typedef enum {
		/// the order of coordinates (this is the type of the first argument of coordinate-handling functions)
		coord_scalar_g1g2_g1g3_g2g3
	} CoordinateOrder;

	/// Constructs a new spinor3 with variable coordinates set to 0.
	inline spinor3() {set();}

	/// Copy constructor.
	inline spinor3(const spinor3 &A) {set(A);}


	/// Constructs a new spinor3 with scalar value 'scalar'.
	inline spinor3(double scalar) {set(scalar);}

	/// Constructs a new spinor3 from mv.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	/// \param filler This argument can have any value; it's role
	/// is only to prevent the compiler from using this constructor as a converter.
	inline spinor3(mv &A, int filler) {set(A);}

	/// Constructs a new spinor3. Coordinate values come from 'A'.
	inline spinor3(const CoordinateOrder co, const double A[4]) {set(co, A);}
	
	/// Constructs a new spinor3 with each coordinate specified.
	inline spinor3(const CoordinateOrder co,  double scalar, double g1_g2, double g1_g3, double g2_g3) {
		set(co, scalar, g1_g2, g1_g3, g2_g3);
	}

	/// Assignment operator (spinor3).
	inline spinor3 &operator=(const spinor3 &A) {if (this != &A) {set(A);} return *this;}
	
		
	/// Assignment operator (double).
	inline spinor3 &operator=(const double &scalar) {set(scalar); return *this;}

	/// Assignment operator (mv).
	inline spinor3 &operator=(const mv &A) {set(A); return *this;}


	/// Sets variable coordinates of 'this' to 0.
	void set();
	/// Sets this to 'A'.
	void set(const spinor3 &A);

	/// Sets this to scalar value 'scalar'.
	void set(double scalar);

	/// Sets this to 'A'.
	/// \param A The value to copy. Coordinates that cannot be represented
	/// are silently dropped.
	void set(const mv &A);


	/// Sets this to 'A'.
	void set(const CoordinateOrder, const double A[4]);
	
	/// Sets this to coordinates specified.
	void set(const CoordinateOrder,  double scalar, double g1_g2, double g1_g3, double g2_g3);

	/// returns the absolute largest coordinate.
	double largestCoordinate() const;
	/// returns the absolute largest coordinate, and the corresponding basis blade bitmap.
	double largestBasisBlade(unsigned int &bm) const;
	

	/// Returns a string representation (const char*) of this multivector.
	/// Not multi-threading safe.
	/// \param fp how floats are printed (e.g., "%f");
	inline const char * c_str(const char *fp = NULL) const {
		static char buf[2048]; // not MT-safe
		return ::m4sta::c_str(*this, buf, 2048, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	/// Not multi-threading safe.
	inline const char * c_str_f() const {return c_str("%f");}
	/// Returns a string representation (const char*) of this multivector using %e
	/// Not multi-threading safe.
	inline const char * c_str_e() const {return c_str("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20 (which is lossless for doubles)
	/// Not multi-threading safe.
	inline const char * c_str_e20() const {return c_str("%2.20e");}

	/// Returns a string representation (const char*) of this multivector.
	inline std::string toString(const char *fp = NULL) const {
		return ::m4sta::toString(*this, fp);
	}
	
	/// Returns a string representation (const char*) of this multivector using %f.
	inline std::string toString_f() const {return toString("%f");}
	/// Returns a string representation (const char*) of this multivector using %e.
	inline std::string toString_e() const {return toString("%e");}
	/// Returns a string representation (const char*) of this multivector using %e20.
	inline std::string toString_e20() const {return toString("%2.20e");}

	/// Returns the 1 coordinate.
	inline double get_scalar() const { return m_c[0];}
	/// Sets the 1 coordinate.
	inline void set_scalar(double scalar) { m_c[0] = scalar;}
	/// Returns the g1^g2 coordinate.
	inline double get_g1_g2() const { return m_c[1];}
	/// Sets the g1^g2 coordinate.
	inline void set_g1_g2(double g1_g2) { m_c[1] = g1_g2;}
	/// Returns the g1^g3 coordinate.
	inline double get_g1_g3() const { return m_c[2];}
	/// Sets the g1^g3 coordinate.
	inline void set_g1_g3(double g1_g3) { m_c[2] = g1_g3;}
	/// Returns the g2^g3 coordinate.
	inline double get_g2_g3() const { return m_c[3];}
	/// Sets the g2^g3 coordinate.
	inline void set_g2_g3(double g2_g3) { m_c[3] = g2_g3;}
	/// Returns array of coordinates.
	inline const double *getC(CoordinateOrder) const { return m_c;}
}; // end of class spinor3
extern g0_t g0;
extern g1_t g1;
extern g2_t g2;
extern g3_t g3;
extern I_t I;
extern I3_t I3;


/**
This class is used to report usage of converted specialized multivectors.

The class is designed to be pretty safe with multi-threading without locking.
In the wordt case, some memory leaks occur and some counts are missed. 
The amount of memory leaked is bounded (goes not grow beyond a certain
point). Since the report-usage functionality is for
development/debugging only, this is not considered non-harmful.
*/
class ReportUsage {
	/// prints out error message that ReportUsage is disabled
	static void printReport(FILE *F = stdout, bool includeCount = true);
}; // end of class ReportUsage

/** Sets 1 double to zero */
void zero_1(double *dst);
/** Copies 1 double from 'src' to 'dst' */
void copy_1(double *dst, const double *src);
/** Sets 2 doubles to zero */
void zero_2(double *dst);
/** Copies 2 doubles from 'src' to 'dst' */
void copy_2(double *dst, const double *src);
/** Sets 3 doubles to zero */
void zero_3(double *dst);
/** Copies 3 doubles from 'src' to 'dst' */
void copy_3(double *dst, const double *src);
/** Sets 4 doubles to zero */
void zero_4(double *dst);
/** Copies 4 doubles from 'src' to 'dst' */
void copy_4(double *dst, const double *src);
/** Sets 5 doubles to zero */
void zero_5(double *dst);
/** Copies 5 doubles from 'src' to 'dst' */
void copy_5(double *dst, const double *src);
/** Sets 6 doubles to zero */
void zero_6(double *dst);
/** Copies 6 doubles from 'src' to 'dst' */
void copy_6(double *dst, const double *src);
/** Sets 7 doubles to zero */
void zero_7(double *dst);
/** Copies 7 doubles from 'src' to 'dst' */
void copy_7(double *dst, const double *src);
/** Sets 8 doubles to zero */
void zero_8(double *dst);
/** Copies 8 doubles from 'src' to 'dst' */
void copy_8(double *dst, const double *src);
/** Sets 9 doubles to zero */
void zero_9(double *dst);
/** Copies 9 doubles from 'src' to 'dst' */
void copy_9(double *dst, const double *src);
/** Sets 10 doubles to zero */
void zero_10(double *dst);
/** Copies 10 doubles from 'src' to 'dst' */
void copy_10(double *dst, const double *src);
/** Sets 11 doubles to zero */
void zero_11(double *dst);
/** Copies 11 doubles from 'src' to 'dst' */
void copy_11(double *dst, const double *src);
/** Sets 12 doubles to zero */
void zero_12(double *dst);
/** Copies 12 doubles from 'src' to 'dst' */
void copy_12(double *dst, const double *src);
/** Sets 13 doubles to zero */
void zero_13(double *dst);
/** Copies 13 doubles from 'src' to 'dst' */
void copy_13(double *dst, const double *src);
/** Sets 14 doubles to zero */
void zero_14(double *dst);
/** Copies 14 doubles from 'src' to 'dst' */
void copy_14(double *dst, const double *src);
/** Sets 15 doubles to zero */
void zero_15(double *dst);
/** Copies 15 doubles from 'src' to 'dst' */
void copy_15(double *dst, const double *src);
/** Sets 16 doubles to zero */
void zero_16(double *dst);
/** Copies 16 doubles from 'src' to 'dst' */
void copy_16(double *dst, const double *src);
/** Sets N doubles to zero */
void zero_N(double *dst, int N);
/** Copies N doubles from 'src' to 'dst' */
void copy_N(double *dst, const double *src, int N);
// decl SB:

/// Returns scalar part of  mv
double _double(const mv &x);
/// Returns scalar part of  mv
inline double _Float(const mv &x) {return _double(x); };

/// Compresses coordinates 'c' into a new multivector.
/// \param c the coordinates (may already be partially compressed, see argument 'gu').
/// \param epsilon value with a abs magnitude < epsilon are considered to be 0.
/// \param gu optionally specifies which groups/grades are present in 'c'.
mv mv_compress(const double *c, double epsilon = 0.0, int gu = 31);
/// Compresses an array of coordinates/basis blade bitmaps into a new multivector.
mv mv_compress(int nbBlades, const unsigned int *bitmaps, const double *coords);


/// Returns scalar part of  g0_t
double _double(const g0_t &x);
/// Returns scalar part of  g0_t
inline double _Float(const g0_t &x) {return _double(x); };
/// Returns scalar part of  g1_t
double _double(const g1_t &x);
/// Returns scalar part of  g1_t
inline double _Float(const g1_t &x) {return _double(x); };
/// Returns scalar part of  g2_t
double _double(const g2_t &x);
/// Returns scalar part of  g2_t
inline double _Float(const g2_t &x) {return _double(x); };
/// Returns scalar part of  g3_t
double _double(const g3_t &x);
/// Returns scalar part of  g3_t
inline double _Float(const g3_t &x) {return _double(x); };
/// Returns scalar part of  I_t
double _double(const I_t &x);
/// Returns scalar part of  I_t
inline double _Float(const I_t &x) {return _double(x); };
/// Returns scalar part of  I3_t
double _double(const I3_t &x);
/// Returns scalar part of  I3_t
inline double _Float(const I3_t &x) {return _double(x); };
/// Returns scalar part of  mv3
double _double(const mv3 &x);
/// Returns scalar part of  mv3
inline double _Float(const mv3 &x) {return _double(x); };
/// Returns scalar part of  vector
double _double(const vector &x);
/// Returns scalar part of  vector
inline double _Float(const vector &x) {return _double(x); };
/// Returns scalar part of  vector3
double _double(const vector3 &x);
/// Returns scalar part of  vector3
inline double _Float(const vector3 &x) {return _double(x); };
/// Returns scalar part of  bivector
double _double(const bivector &x);
/// Returns scalar part of  bivector
inline double _Float(const bivector &x) {return _double(x); };
/// Returns scalar part of  bivector3
double _double(const bivector3 &x);
/// Returns scalar part of  bivector3
inline double _Float(const bivector3 &x) {return _double(x); };
/// Returns scalar part of  pseudovector
double _double(const pseudovector &x);
/// Returns scalar part of  pseudovector
inline double _Float(const pseudovector &x) {return _double(x); };
/// Returns scalar part of  spinor
double _double(const spinor &x);
/// Returns scalar part of  spinor
inline double _Float(const spinor &x) {return _double(x); };
/// Returns scalar part of  spinor3
double _double(const spinor3 &x);
/// Returns scalar part of  spinor3
inline double _Float(const spinor3 &x) {return _double(x); };
/** Converts vector to vector3: dst = a. */
vector3 _vector3(const vector &a);
/** Converts bivector to bivector3: dst = a. */
bivector3 _bivector3(const bivector &a);
/** Converts spinor to spinor3: dst = a. */
spinor3 _spinor3(const spinor &a);
/// Returns grade groupBitmap of  mv.
mv extractGrade(const mv &a, int groupBitmap);
/// Returns grade 0 of  mv.
mv extractGrade0(const mv &a);
/// Returns grade 0 of  mv3.
double extractGrade0(const mv3 &a);
/// Returns grade 0 of  vector.
double extractGrade0(const vector &a);
/// Returns grade 0 of  vector3.
double extractGrade0(const vector3 &a);
/// Returns grade 0 of  bivector.
double extractGrade0(const bivector &a);
/// Returns grade 0 of  bivector3.
double extractGrade0(const bivector3 &a);
/// Returns grade 0 of  pseudovector.
double extractGrade0(const pseudovector &a);
/// Returns grade 0 of  spinor.
double extractGrade0(const spinor &a);
/// Returns grade 0 of  spinor3.
double extractGrade0(const spinor3 &a);
/// Returns grade 1 of  mv.
mv extractGrade1(const mv &a);
/// Returns grade 1 of  mv3.
vector3 extractGrade1(const mv3 &a);
/// Returns grade 1 of  vector.
vector extractGrade1(const vector &a);
/// Returns grade 1 of  vector3.
vector3 extractGrade1(const vector3 &a);
/// Returns grade 1 of  bivector.
double extractGrade1(const bivector &a);
/// Returns grade 1 of  bivector3.
double extractGrade1(const bivector3 &a);
/// Returns grade 1 of  pseudovector.
double extractGrade1(const pseudovector &a);
/// Returns grade 1 of  spinor.
double extractGrade1(const spinor &a);
/// Returns grade 1 of  spinor3.
double extractGrade1(const spinor3 &a);
/// Returns grade 2 of  mv.
mv extractGrade2(const mv &a);
/// Returns grade 2 of  mv3.
bivector3 extractGrade2(const mv3 &a);
/// Returns grade 2 of  vector.
double extractGrade2(const vector &a);
/// Returns grade 2 of  vector3.
double extractGrade2(const vector3 &a);
/// Returns grade 2 of  bivector.
bivector extractGrade2(const bivector &a);
/// Returns grade 2 of  bivector3.
bivector3 extractGrade2(const bivector3 &a);
/// Returns grade 2 of  pseudovector.
double extractGrade2(const pseudovector &a);
/// Returns grade 2 of  spinor.
bivector extractGrade2(const spinor &a);
/// Returns grade 2 of  spinor3.
bivector3 extractGrade2(const spinor3 &a);
/// Returns grade 3 of  mv.
mv extractGrade3(const mv &a);
/// Returns grade 3 of  mv3.
pseudovector extractGrade3(const mv3 &a);
/// Returns grade 3 of  vector.
double extractGrade3(const vector &a);
/// Returns grade 3 of  vector3.
double extractGrade3(const vector3 &a);
/// Returns grade 3 of  bivector.
double extractGrade3(const bivector &a);
/// Returns grade 3 of  bivector3.
double extractGrade3(const bivector3 &a);
/// Returns grade 3 of  pseudovector.
pseudovector extractGrade3(const pseudovector &a);
/// Returns grade 3 of  spinor.
double extractGrade3(const spinor &a);
/// Returns grade 3 of  spinor3.
double extractGrade3(const spinor3 &a);
/// Returns grade 4 of  mv.
mv extractGrade4(const mv &a);
/// Returns grade 4 of  mv3.
double extractGrade4(const mv3 &a);
/// Returns grade 4 of  vector.
double extractGrade4(const vector &a);
/// Returns grade 4 of  vector3.
double extractGrade4(const vector3 &a);
/// Returns grade 4 of  bivector.
double extractGrade4(const bivector &a);
/// Returns grade 4 of  bivector3.
double extractGrade4(const bivector3 &a);
/// Returns grade 4 of  pseudovector.
double extractGrade4(const pseudovector &a);
/// Returns grade 4 of  spinor.
spinor extractGrade4(const spinor &a);
/// Returns grade 4 of  spinor3.
double extractGrade4(const spinor3 &a);
/// Returns mv + mv.
mv add(const mv &a, const mv &b);
/// Returns mv3 + mv3.
mv3 add(const mv3 &a, const mv3 &b);
/// Returns vector + vector.
vector add(const vector &a, const vector &b);
/// Returns vector3 + vector3.
vector3 add(const vector3 &a, const vector3 &b);
/// Returns bivector + bivector.
bivector add(const bivector &a, const bivector &b);
/// Returns bivector3 + bivector3.
bivector3 add(const bivector3 &a, const bivector3 &b);
/// Returns pseudovector + pseudovector.
pseudovector add(const pseudovector &a, const pseudovector &b);
/// Returns spinor + spinor.
spinor add(const spinor &a, const spinor &b);
/// Returns spinor3 + spinor3.
spinor3 add(const spinor3 &a, const spinor3 &b);
/// Returns mv - mv.
mv subtract(const mv &a, const mv &b);
/// Returns mv3 - mv3.
mv3 subtract(const mv3 &a, const mv3 &b);
/// Returns vector - vector.
vector subtract(const vector &a, const vector &b);
/// Returns vector3 - vector3.
vector3 subtract(const vector3 &a, const vector3 &b);
/// Returns bivector - bivector.
bivector subtract(const bivector &a, const bivector &b);
/// Returns bivector3 - bivector3.
bivector3 subtract(const bivector3 &a, const bivector3 &b);
/// Returns pseudovector - pseudovector.
pseudovector subtract(const pseudovector &a, const pseudovector &b);
/// Returns spinor - spinor.
spinor subtract(const spinor &a, const spinor &b);
/// Returns spinor3 - spinor3.
spinor3 subtract(const spinor3 &a, const spinor3 &b);
/// Returns geometric product of double and mv.
mv gp(const double a, const mv &b);
/// Returns geometric product of double and mv3.
mv3 gp(const double a, const mv3 &b);
/// Returns geometric product of double and vector.
vector gp(const double a, const vector &b);
/// Returns geometric product of double and vector3.
vector3 gp(const double a, const vector3 &b);
/// Returns geometric product of double and bivector.
bivector gp(const double a, const bivector &b);
/// Returns geometric product of double and bivector3.
bivector3 gp(const double a, const bivector3 &b);
/// Returns geometric product of double and pseudovector.
pseudovector gp(const double a, const pseudovector &b);
/// Returns geometric product of double and spinor.
spinor gp(const double a, const spinor &b);
/// Returns geometric product of double and spinor3.
spinor3 gp(const double a, const spinor3 &b);
/// Returns geometric product of mv and double.
mv gp(const mv &a, const double b);
/// Returns geometric product of mv3 and double.
mv3 gp(const mv3 &a, const double b);
/// Returns geometric product of vector and double.
vector gp(const vector &a, const double b);
/// Returns geometric product of vector3 and double.
vector3 gp(const vector3 &a, const double b);
/// Returns geometric product of bivector and double.
bivector gp(const bivector &a, const double b);
/// Returns geometric product of bivector3 and double.
bivector3 gp(const bivector3 &a, const double b);
/// Returns geometric product of pseudovector and double.
pseudovector gp(const pseudovector &a, const double b);
/// Returns geometric product of spinor and double.
spinor gp(const spinor &a, const double b);
/// Returns geometric product of spinor3 and double.
spinor3 gp(const spinor3 &a, const double b);
/// Returns a / b
mv div(const mv &a, const double b);
/// Returns a / b
mv3 div(const mv3 &a, const double b);
/// Returns a / b
vector div(const vector &a, const double b);
/// Returns a / b
vector3 div(const vector3 &a, const double b);
/// Returns a / b
bivector div(const bivector &a, const double b);
/// Returns a / b
bivector3 div(const bivector3 &a, const double b);
/// Returns a / b
pseudovector div(const pseudovector &a, const double b);
/// Returns a / b
spinor div(const spinor &a, const double b);
/// Returns a / b
spinor3 div(const spinor3 &a, const double b);
/// Returns geometric product of mv and mv.
mv gp(const mv &a, const mv &b);
/// Returns geometric product of spinor and spinor.
spinor gp(const spinor &a, const spinor &b);
/// Returns geometric product of spinor3 and spinor3.
spinor3 gp(const spinor3 &a, const spinor3 &b);
/// Returns right contraction of mv and mv.
mv rc(const mv &a, const mv &b);
/// Returns left contraction of mv and mv.
mv lc(const mv &a, const mv &b);
/// Returns scalar product of mv and mv.
double sp(const mv &a, const mv &b);
/// Returns scalar product of mv3 and mv3.
double sp(const mv3 &a, const mv3 &b);
/// Returns scalar product of vector and vector.
double sp(const vector &a, const vector &b);
/// Returns scalar product of vector3 and vector3.
double sp(const vector3 &a, const vector3 &b);
/// Returns scalar product of bivector and bivector.
double sp(const bivector &a, const bivector &b);
/// Returns scalar product of bivector3 and bivector3.
double sp(const bivector3 &a, const bivector3 &b);
/// Returns scalar product of pseudovector and pseudovector.
double sp(const pseudovector &a, const pseudovector &b);
/// Returns scalar product of spinor and spinor.
double sp(const spinor &a, const spinor &b);
/// Returns scalar product of spinor3 and spinor3.
double sp(const spinor3 &a, const spinor3 &b);
/// Returns outer product of mv and mv.
mv op(const mv &a, const mv &b);
/// Returns outer product of vector and vector.
bivector op(const vector &a, const vector &b);
/// Returns outer product of vector3 and vector3.
bivector3 op(const vector3 &a, const vector3 &b);
/// Returns outer product of bivector and bivector.
spinor op(const bivector &a, const bivector &b);
/// Returns outer product of bivector3 and bivector3.
double op(const bivector3 &a, const bivector3 &b);
/// Returns dual of mv using default metric.
mv dual(const mv &a);
/// Returns dual of vector using default metric.
pseudovector dual(const vector &a);
/// Returns dual of bivector using default metric.
bivector dual(const bivector &a);
/// Returns dual of pseudovector using default metric.
vector dual(const pseudovector &a);
/// Returns dual of spinor using default metric.
spinor dual(const spinor &a);
/// Returns negation of mv.
mv negate(const mv &a);
/// Returns negation of mv3.
mv3 negate(const mv3 &a);
/// Returns negation of vector.
vector negate(const vector &a);
/// Returns negation of vector3.
vector3 negate(const vector3 &a);
/// Returns negation of bivector.
bivector negate(const bivector &a);
/// Returns negation of bivector3.
bivector3 negate(const bivector3 &a);
/// Returns negation of pseudovector.
pseudovector negate(const pseudovector &a);
/// Returns negation of spinor.
spinor negate(const spinor &a);
/// Returns negation of spinor3.
spinor3 negate(const spinor3 &a);
/// Returns reverse of mv.
mv reverse(const mv &a);
/// Returns reverse of mv3.
mv3 reverse(const mv3 &a);
/// Returns reverse of vector.
vector reverse(const vector &a);
/// Returns reverse of vector3.
vector3 reverse(const vector3 &a);
/// Returns reverse of bivector.
bivector reverse(const bivector &a);
/// Returns reverse of bivector3.
bivector3 reverse(const bivector3 &a);
/// Returns reverse of pseudovector.
pseudovector reverse(const pseudovector &a);
/// Returns reverse of spinor.
spinor reverse(const spinor &a);
/// Returns reverse of spinor3.
spinor3 reverse(const spinor3 &a);
/// Returns Clifford conjugate of mv.
mv cliffordConjugate(const mv &a);
/// Returns Clifford conjugate of mv3.
mv3 cliffordConjugate(const mv3 &a);
/// Returns Clifford conjugate of vector.
vector cliffordConjugate(const vector &a);
/// Returns Clifford conjugate of vector3.
vector3 cliffordConjugate(const vector3 &a);
/// Returns Clifford conjugate of bivector.
bivector cliffordConjugate(const bivector &a);
/// Returns Clifford conjugate of bivector3.
bivector3 cliffordConjugate(const bivector3 &a);
/// Returns Clifford conjugate of pseudovector.
pseudovector cliffordConjugate(const pseudovector &a);
/// Returns Clifford conjugate of spinor.
spinor cliffordConjugate(const spinor &a);
/// Returns Clifford conjugate of spinor3.
spinor3 cliffordConjugate(const spinor3 &a);
/// Returns grade involution of mv.
mv gradeInvolution(const mv &a);
/// Returns grade involution of mv3.
mv3 gradeInvolution(const mv3 &a);
/// Returns grade involution of vector.
vector gradeInvolution(const vector &a);
/// Returns grade involution of vector3.
vector3 gradeInvolution(const vector3 &a);
/// Returns grade involution of bivector.
bivector gradeInvolution(const bivector &a);
/// Returns grade involution of bivector3.
bivector3 gradeInvolution(const bivector3 &a);
/// Returns grade involution of pseudovector.
pseudovector gradeInvolution(const pseudovector &a);
/// Returns grade involution of spinor.
spinor gradeInvolution(const spinor &a);
/// Returns grade involution of spinor3.
spinor3 gradeInvolution(const spinor3 &a);
/// Returns norm of mv using default metric.
double norm(const mv &a);
/// internal conversion function
double norm_returns_scalar(const mv &a);
/// Returns norm of mv3 using default metric.
double norm(const mv3 &a);
/// internal conversion function
double norm_returns_scalar(const mv3 &a);
/// Returns norm of vector using default metric.
double norm(const vector &a);
/// internal conversion function
double norm_returns_scalar(const vector &a);
/// Returns norm of vector3 using default metric.
double norm(const vector3 &a);
/// internal conversion function
double norm_returns_scalar(const vector3 &a);
/// Returns norm of bivector using default metric.
double norm(const bivector &a);
/// internal conversion function
double norm_returns_scalar(const bivector &a);
/// Returns norm of bivector3 using default metric.
double norm(const bivector3 &a);
/// internal conversion function
double norm_returns_scalar(const bivector3 &a);
/// Returns norm of pseudovector using default metric.
double norm(const pseudovector &a);
/// internal conversion function
double norm_returns_scalar(const pseudovector &a);
/// Returns norm of spinor using default metric.
double norm(const spinor &a);
/// internal conversion function
double norm_returns_scalar(const spinor &a);
/// Returns norm of spinor3 using default metric.
double norm(const spinor3 &a);
/// internal conversion function
double norm_returns_scalar(const spinor3 &a);
/// Returns norm2 of mv using default metric.
double norm2(const mv &a);
/// internal conversion function
double norm2_returns_scalar(const mv &a);
/// Returns norm2 of mv3 using default metric.
double norm2(const mv3 &a);
/// internal conversion function
double norm2_returns_scalar(const mv3 &a);
/// Returns norm2 of vector using default metric.
double norm2(const vector &a);
/// internal conversion function
double norm2_returns_scalar(const vector &a);
/// Returns norm2 of vector3 using default metric.
double norm2(const vector3 &a);
/// internal conversion function
double norm2_returns_scalar(const vector3 &a);
/// Returns norm2 of bivector using default metric.
double norm2(const bivector &a);
/// internal conversion function
double norm2_returns_scalar(const bivector &a);
/// Returns norm2 of bivector3 using default metric.
double norm2(const bivector3 &a);
/// internal conversion function
double norm2_returns_scalar(const bivector3 &a);
/// Returns norm2 of pseudovector using default metric.
double norm2(const pseudovector &a);
/// internal conversion function
double norm2_returns_scalar(const pseudovector &a);
/// Returns norm2 of spinor using default metric.
double norm2(const spinor &a);
/// internal conversion function
double norm2_returns_scalar(const spinor &a);
/// Returns norm2 of spinor3 using default metric.
double norm2(const spinor3 &a);
/// internal conversion function
double norm2_returns_scalar(const spinor3 &a);
/// Returns norm2 of mv using euclidean metric.
double norm2_euclidean(const mv &a);
/// internal conversion function
double norm2_euclidean_returns_scalar(const mv &a);
/// Returns unit of mv using default metric.
mv unit(const mv &a);
/// Returns unit of mv3 using default metric.
mv3 unit(const mv3 &a);
/// Returns unit of vector using default metric.
vector unit(const vector &a);
/// Returns unit of vector3 using default metric.
vector3 unit(const vector3 &a);
/// Returns unit of bivector using default metric.
bivector unit(const bivector &a);
/// Returns unit of bivector3 using default metric.
bivector3 unit(const bivector3 &a);
/// Returns unit of pseudovector using default metric.
pseudovector unit(const pseudovector &a);
/// Returns unit of spinor using default metric.
spinor unit(const spinor &a);
/// Returns unit of spinor3 using default metric.
spinor3 unit(const spinor3 &a);
/// Returns versor inverse of a using default metric.
mv versorInverse(const mv &a);
/// Returns versor inverse of a using default metric.
spinor3 versorInverse(const spinor3 &a);
/// Returns versor inverse of a using default metric.
spinor versorInverse(const spinor &a);
/// Returns double b * mv a + double c.
mv sas(const mv &a, const double b, const double c);
/// Returns double b * spinor3 a + double c.
spinor3 sas(const spinor3 &a, const double b, const double c);
/// Returns double b * spinor a + double c.
spinor sas(const spinor &a, const double b, const double c);
/// Returns logarithm of mv3 using euclidean metric, assuming a 3D Euclidean rotor.
bivector3 log(const mv3 &a);
/// Returns logarithm of spinor3 using euclidean metric, assuming a 3D Euclidean rotor.
bivector3 log(const spinor3 &a);

/** Computes exp of mv.
 */
mv exp(const mv &x, int order = 12);

/** Computes exp of spinor3.
 */
spinor3 exp(const spinor3 &x, int order = 12);

/** Computes exp of spinor.
 */
spinor exp(const spinor &x, int order = 12);

/** Computes sin of mv.
 */
mv sin(const mv &x, int order = 12);

/** Computes sin of spinor3.
 */
spinor3 sin(const spinor3 &x, int order = 12);

/** Computes sin of spinor.
 */
spinor sin(const spinor &x, int order = 12);

/** Computes cos of mv.
 */
mv cos(const mv &x, int order = 12);

/** Computes cos of spinor3.
 */
spinor3 cos(const spinor3 &x, int order = 12);

/** Computes cos of spinor.
 */
spinor cos(const spinor &x, int order = 12);

/** Computes sinh of mv.
 */
mv sinh(const mv &x, int order = 12);

/** Computes sinh of spinor3.
 */
spinor3 sinh(const spinor3 &x, int order = 12);

/** Computes sinh of spinor.
 */
spinor sinh(const spinor &x, int order = 12);

/** Computes cosh of mv.
 */
mv cosh(const mv &x, int order = 12);

/** Computes cosh of spinor3.
 */
spinor3 cosh(const spinor3 &x, int order = 12);

/** Computes cosh of spinor.
 */
spinor cosh(const spinor &x, int order = 12);
/// Returns R * v * inverse(R) using default metric.
vector applyVersor(const spinor &R, const vector &v);
/// Returns R * v * reverse(R) using default metric. Only gives the correct result when the versor has a positive squared norm.
/// 
vector3 applyUnitVersor(const spinor3 &R, const vector3 &v);
/// returns add(a, b)
inline mv operator+(const mv &a, const mv &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline mv &operator+=(mv &a, const mv &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline mv3 operator+(const mv3 &a, const mv3 &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline mv3 &operator+=(mv3 &a, const mv3 &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline vector operator+(const vector &a, const vector &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline vector &operator+=(vector &a, const vector &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline vector3 operator+(const vector3 &a, const vector3 &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline vector3 &operator+=(vector3 &a, const vector3 &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline bivector operator+(const bivector &a, const bivector &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline bivector &operator+=(bivector &a, const bivector &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline bivector3 operator+(const bivector3 &a, const bivector3 &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline bivector3 &operator+=(bivector3 &a, const bivector3 &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline pseudovector operator+(const pseudovector &a, const pseudovector &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline pseudovector &operator+=(pseudovector &a, const pseudovector &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline spinor operator+(const spinor &a, const spinor &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline spinor &operator+=(spinor &a, const spinor &b) {
	return (a = add(a, b));
}
/// returns add(a, b)
inline spinor3 operator+(const spinor3 &a, const spinor3 &b) {
	return add(a, b);
}
/// returns (a = add(a, b))
inline spinor3 &operator+=(spinor3 &a, const spinor3 &b) {
	return (a = add(a, b));
}
/// returns subtract(a, b)
inline mv operator-(const mv &a, const mv &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline mv &operator-=(mv &a, const mv &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline mv3 operator-(const mv3 &a, const mv3 &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline mv3 &operator-=(mv3 &a, const mv3 &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline vector operator-(const vector &a, const vector &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline vector &operator-=(vector &a, const vector &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline vector3 operator-(const vector3 &a, const vector3 &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline vector3 &operator-=(vector3 &a, const vector3 &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline bivector operator-(const bivector &a, const bivector &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline bivector &operator-=(bivector &a, const bivector &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline bivector3 operator-(const bivector3 &a, const bivector3 &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline bivector3 &operator-=(bivector3 &a, const bivector3 &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline pseudovector operator-(const pseudovector &a, const pseudovector &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline pseudovector &operator-=(pseudovector &a, const pseudovector &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline spinor operator-(const spinor &a, const spinor &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline spinor &operator-=(spinor &a, const spinor &b) {
	return (a = subtract(a, b));
}
/// returns subtract(a, b)
inline spinor3 operator-(const spinor3 &a, const spinor3 &b) {
	return subtract(a, b);
}
/// returns (a = subtract(a, b))
inline spinor3 &operator-=(spinor3 &a, const spinor3 &b) {
	return (a = subtract(a, b));
}
/// returns gp(a, b)
inline mv operator*(const double &a, const mv &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline mv3 operator*(const double &a, const mv3 &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline vector operator*(const double &a, const vector &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline vector3 operator*(const double &a, const vector3 &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline bivector operator*(const double &a, const bivector &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline bivector3 operator*(const double &a, const bivector3 &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline pseudovector operator*(const double &a, const pseudovector &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline spinor operator*(const double &a, const spinor &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline spinor3 operator*(const double &a, const spinor3 &b) {
	return gp(a, b);
}
/// returns gp(a, b)
inline mv operator*(const mv &a, const double &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline mv &operator*=(mv &a, const double &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline mv3 operator*(const mv3 &a, const double &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline mv3 &operator*=(mv3 &a, const double &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline vector operator*(const vector &a, const double &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline vector &operator*=(vector &a, const double &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline vector3 operator*(const vector3 &a, const double &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline vector3 &operator*=(vector3 &a, const double &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline bivector operator*(const bivector &a, const double &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline bivector &operator*=(bivector &a, const double &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline bivector3 operator*(const bivector3 &a, const double &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline bivector3 &operator*=(bivector3 &a, const double &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline pseudovector operator*(const pseudovector &a, const double &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline pseudovector &operator*=(pseudovector &a, const double &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline spinor operator*(const spinor &a, const double &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline spinor &operator*=(spinor &a, const double &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline spinor3 operator*(const spinor3 &a, const double &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline spinor3 &operator*=(spinor3 &a, const double &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline mv operator*(const mv &a, const mv &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline mv &operator*=(mv &a, const mv &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline spinor operator*(const spinor &a, const spinor &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline spinor &operator*=(spinor &a, const spinor &b) {
	return (a = gp(a, b));
}
/// returns gp(a, b)
inline spinor3 operator*(const spinor3 &a, const spinor3 &b) {
	return gp(a, b);
}
/// returns (a = gp(a, b))
inline spinor3 &operator*=(spinor3 &a, const spinor3 &b) {
	return (a = gp(a, b));
}
/// returns rc(a, b)
inline mv operator>>(const mv &a, const mv &b) {
	return rc(a, b);
}
/// returns (a = rc(a, b))
inline mv &operator>>=(mv &a, const mv &b) {
	return (a = rc(a, b));
}
/// returns lc(a, b)
inline mv operator<<(const mv &a, const mv &b) {
	return lc(a, b);
}
/// returns (a = lc(a, b))
inline mv &operator<<=(mv &a, const mv &b) {
	return (a = lc(a, b));
}
/// returns sp(a, b)
inline mv operator%(const mv &a, const mv &b) {
	return sp(a, b);
}
/// returns (a = sp(a, b))
inline mv &operator%=(mv &a, const mv &b) {
	return (a = sp(a, b));
}
/// returns sp(a, b)
inline double operator%(const mv3 &a, const mv3 &b) {
	return sp(a, b);
}
/// returns sp(a, b)
inline double operator%(const vector &a, const vector &b) {
	return sp(a, b);
}
/// returns sp(a, b)
inline double operator%(const vector3 &a, const vector3 &b) {
	return sp(a, b);
}
/// returns sp(a, b)
inline double operator%(const bivector &a, const bivector &b) {
	return sp(a, b);
}
/// returns sp(a, b)
inline double operator%(const bivector3 &a, const bivector3 &b) {
	return sp(a, b);
}
/// returns sp(a, b)
inline double operator%(const pseudovector &a, const pseudovector &b) {
	return sp(a, b);
}
/// returns sp(a, b)
inline double operator%(const spinor &a, const spinor &b) {
	return sp(a, b);
}
/// returns sp(a, b)
inline double operator%(const spinor3 &a, const spinor3 &b) {
	return sp(a, b);
}
/// returns op(a, b)
inline mv operator^(const mv &a, const mv &b) {
	return op(a, b);
}
/// returns (a = op(a, b))
inline mv &operator^=(mv &a, const mv &b) {
	return (a = op(a, b));
}
/// returns op(a, b)
inline bivector operator^(const vector &a, const vector &b) {
	return op(a, b);
}
/// returns op(a, b)
inline bivector3 operator^(const vector3 &a, const vector3 &b) {
	return op(a, b);
}
/// returns op(a, b)
inline spinor operator^(const bivector &a, const bivector &b) {
	return op(a, b);
}
/// returns op(a, b)
inline double operator^(const bivector3 &a, const bivector3 &b) {
	return op(a, b);
}
/// returns dual(a)
inline mv operator*(const mv &a) {
	return dual(a);
}
/// returns dual(a)
inline pseudovector operator*(const vector &a) {
	return dual(a);
}
/// returns dual(a)
inline bivector operator*(const bivector &a) {
	return dual(a);
}
/// returns dual(a)
inline vector operator*(const pseudovector &a) {
	return dual(a);
}
/// returns dual(a)
inline spinor operator*(const spinor &a) {
	return dual(a);
}
/// returns negate(a)
inline mv operator-(const mv &a) {
	return negate(a);
}
/// returns negate(a)
inline mv3 operator-(const mv3 &a) {
	return negate(a);
}
/// returns negate(a)
inline vector operator-(const vector &a) {
	return negate(a);
}
/// returns negate(a)
inline vector3 operator-(const vector3 &a) {
	return negate(a);
}
/// returns negate(a)
inline bivector operator-(const bivector &a) {
	return negate(a);
}
/// returns negate(a)
inline bivector3 operator-(const bivector3 &a) {
	return negate(a);
}
/// returns negate(a)
inline pseudovector operator-(const pseudovector &a) {
	return negate(a);
}
/// returns negate(a)
inline spinor operator-(const spinor &a) {
	return negate(a);
}
/// returns negate(a)
inline spinor3 operator-(const spinor3 &a) {
	return negate(a);
}
/// returns reverse(a)
inline mv operator~(const mv &a) {
	return reverse(a);
}
/// returns reverse(a)
inline mv3 operator~(const mv3 &a) {
	return reverse(a);
}
/// returns reverse(a)
inline vector operator~(const vector &a) {
	return reverse(a);
}
/// returns reverse(a)
inline vector3 operator~(const vector3 &a) {
	return reverse(a);
}
/// returns reverse(a)
inline bivector operator~(const bivector &a) {
	return reverse(a);
}
/// returns reverse(a)
inline bivector3 operator~(const bivector3 &a) {
	return reverse(a);
}
/// returns reverse(a)
inline pseudovector operator~(const pseudovector &a) {
	return reverse(a);
}
/// returns reverse(a)
inline spinor operator~(const spinor &a) {
	return reverse(a);
}
/// returns reverse(a)
inline spinor3 operator~(const spinor3 &a) {
	return reverse(a);
}
/// returns versorInverse(a)
inline mv operator!(const mv &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline spinor3 operator!(const spinor3 &a) {
	return versorInverse(a);
}
/// returns versorInverse(a)
inline spinor operator!(const spinor &a) {
	return versorInverse(a);
}

inline void zero_1(double *dst) {
	dst[0]=0.0;
}
inline void copy_1(double *dst, const double *src) {
	dst[0] = src[0];
}
inline void zero_2(double *dst) {
	dst[0]=dst[1]=0.0;
}
inline void copy_2(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
}
inline void zero_3(double *dst) {
	dst[0]=dst[1]=dst[2]=0.0;
}
inline void copy_3(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
}
inline void zero_4(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=0.0;
}
inline void copy_4(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
}
inline void zero_5(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=0.0;
}
inline void copy_5(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
}
inline void zero_6(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=0.0;
}
inline void copy_6(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
}
inline void zero_7(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=0.0;
}
inline void copy_7(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
}
inline void zero_8(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=0.0;
}
inline void copy_8(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
}
inline void zero_9(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=0.0;
}
inline void copy_9(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
}
inline void zero_10(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=0.0;
}
inline void copy_10(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
}
inline void zero_11(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=0.0;
}
inline void copy_11(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
}
inline void zero_12(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=0.0;
}
inline void copy_12(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
}
inline void zero_13(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=0.0;
}
inline void copy_13(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
}
inline void zero_14(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=0.0;
}
inline void copy_14(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
}
inline void zero_15(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=dst[14]=0.0;
}
inline void copy_15(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
	dst[14] = src[14];
}
inline void zero_16(double *dst) {
	dst[0]=dst[1]=dst[2]=dst[3]=dst[4]=dst[5]=dst[6]=dst[7]=dst[8]=dst[9]=dst[10]=dst[11]=dst[12]=dst[13]=dst[14]=dst[15]=0.0;
}
inline void copy_16(double *dst, const double *src) {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = src[2];
	dst[3] = src[3];
	dst[4] = src[4];
	dst[5] = src[5];
	dst[6] = src[6];
	dst[7] = src[7];
	dst[8] = src[8];
	dst[9] = src[9];
	dst[10] = src[10];
	dst[11] = src[11];
	dst[12] = src[12];
	dst[13] = src[13];
	dst[14] = src[14];
	dst[15] = src[15];
}
/** Sets N doubles to zero */
inline void zero_N(double *dst, int N) {
	int i = 0;
	while ((N-i) > 16) {
		zero_16(dst + i);
		i += 16;
	}
	for (; i < N; i++)
		dst[i] = 0.0;
}
/** Copies N doubles from 'src' to 'dst' */
inline void copy_N(double *dst, const double *src, int N) {
	int i = 0;
	while ((N-i) > 16) {
		copy_16(dst + i, src + i);
		i += 16;
	}
	for (; i < N; i++)
		dst[i] = src[i];
}
// inline def SB:
inline void mv::set() {
	setGroupUsage(0);
}
inline void mv::set(double val) {
	setGroupUsage(1);
	m_c[0] = val;
}
inline void mv::set(int gu, const double *arr) {
	setGroupUsage(gu);
	m4sta::copy_N(m_c, arr, m4sta_mvSize[gu]);

}
inline void mv::set(const mv &src) {
	setGroupUsage(src.gu());
	const double*srcC = src.getC();
	m4sta::copy_N(m_c, srcC, m4sta_mvSize[src.gu()]);

}
inline void g0_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void g1_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void g2_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void g3_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
	}
	else {
	}
}
inline void I_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		ptr += 6;
	}
	if (src.gu() & 8) {
		ptr += 4;
	}
	if (src.gu() & 16) {
	}
	else {
	}
}
inline void I3_t::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		ptr += 6;
	}
	if (src.gu() & 8) {
	}
	else {
	}
}
inline void mv3::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		m_c[0] = ptr[0];
		ptr += 1;
	}
	else {
		m_c[0] = 0.0;
	}
	if (src.gu() & 2) {
		m_c[1] = ptr[1];
		m_c[2] = ptr[2];
		m_c[3] = ptr[3];
		ptr += 4;
	}
	else {
		m_c[1] = 0.0;
		m_c[2] = 0.0;
		m_c[3] = 0.0;
	}
	if (src.gu() & 4) {
		m_c[4] = ptr[2];
		m_c[5] = ptr[4];
		m_c[6] = ptr[5];
		ptr += 6;
	}
	else {
		m_c[4] = 0.0;
		m_c[5] = 0.0;
		m_c[6] = 0.0;
	}
	if (src.gu() & 8) {
		m_c[7] = ptr[3];
	}
	else {
		m_c[7] = 0.0;
	}
}
inline void vector::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		m_c[0] = ptr[0];
		m_c[1] = ptr[1];
		m_c[2] = ptr[2];
		m_c[3] = ptr[3];
	}
	else {
		m_c[0] = 0.0;
		m_c[1] = 0.0;
		m_c[2] = 0.0;
		m_c[3] = 0.0;
	}
}
inline void vector3::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		m_c[0] = ptr[1];
		m_c[1] = ptr[2];
		m_c[2] = ptr[3];
	}
	else {
		m_c[0] = 0.0;
		m_c[1] = 0.0;
		m_c[2] = 0.0;
	}
}
inline void bivector::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		m_c[0] = ptr[0];
		m_c[1] = ptr[1];
		m_c[2] = ptr[3];
		m_c[3] = ptr[2];
		m_c[4] = ptr[4];
		m_c[5] = ptr[5];
	}
	else {
		m_c[0] = 0.0;
		m_c[1] = 0.0;
		m_c[2] = 0.0;
		m_c[3] = 0.0;
		m_c[4] = 0.0;
		m_c[5] = 0.0;
	}
}
inline void bivector3::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		m_c[0] = ptr[2];
		m_c[1] = ptr[4];
		m_c[2] = ptr[5];
	}
	else {
		m_c[0] = 0.0;
		m_c[1] = 0.0;
		m_c[2] = 0.0;
	}
}
inline void pseudovector::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		ptr += 1;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		ptr += 6;
	}
	if (src.gu() & 8) {
		m_c[0] = ptr[0];
		m_c[1] = ptr[1];
		m_c[2] = ptr[2];
		m_c[3] = ptr[3];
	}
	else {
		m_c[0] = 0.0;
		m_c[1] = 0.0;
		m_c[2] = 0.0;
		m_c[3] = 0.0;
	}
}
inline void spinor::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		m_c[0] = ptr[0];
		ptr += 1;
	}
	else {
		m_c[0] = 0.0;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		m_c[1] = ptr[0];
		m_c[2] = ptr[1];
		m_c[3] = ptr[3];
		m_c[4] = ptr[2];
		m_c[5] = ptr[4];
		m_c[6] = ptr[5];
		ptr += 6;
	}
	else {
		m_c[1] = 0.0;
		m_c[2] = 0.0;
		m_c[3] = 0.0;
		m_c[4] = 0.0;
		m_c[5] = 0.0;
		m_c[6] = 0.0;
	}
	if (src.gu() & 8) {
		ptr += 4;
	}
	if (src.gu() & 16) {
		m_c[7] = ptr[0];
	}
	else {
		m_c[7] = 0.0;
	}
}
inline void spinor3::set(const mv &src) {
	const double *ptr = src.getC();

	if (src.gu() & 1) {
		m_c[0] = ptr[0];
		ptr += 1;
	}
	else {
		m_c[0] = 0.0;
	}
	if (src.gu() & 2) {
		ptr += 4;
	}
	if (src.gu() & 4) {
		m_c[1] = ptr[2];
		m_c[2] = ptr[4];
		m_c[3] = ptr[5];
	}
	else {
		m_c[1] = 0.0;
		m_c[2] = 0.0;
		m_c[3] = 0.0;
	}
}
inline void mv::set(const g0_t &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = 1.0;
	ptr[1] = ptr[2] = ptr[3] = 0.0;
}
inline void mv::set(const g1_t &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = ptr[2] = ptr[3] = 0.0;
	ptr[1] = 1.0;
}
inline void mv::set(const g2_t &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[3] = 0.0;
	ptr[2] = 1.0;
}
inline void mv::set(const g3_t &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = 0.0;
	ptr[3] = 1.0;
}
inline void mv::set(const I_t &src) {
	setGroupUsage(16);
	double *ptr = m_c;
	ptr[0] = 1.0;
}
inline void mv::set(const I3_t &src) {
	setGroupUsage(8);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[2] = 0.0;
	ptr[3] = 1.0;
}
inline void mv::set(const mv3 &src) {
	setGroupUsage(15);
	double *ptr = m_c;
	ptr[0] = src.m_c[0];
	ptr += 1;
	ptr[0] = 0.0;
	ptr[1] = src.m_c[1];
	ptr[2] = src.m_c[2];
	ptr[3] = src.m_c[3];
	ptr += 4;
	ptr[0] = ptr[1] = ptr[3] = 0.0;
	ptr[2] = src.m_c[4];
	ptr[4] = src.m_c[5];
	ptr[5] = src.m_c[6];
	ptr += 6;
	ptr[0] = ptr[1] = ptr[2] = 0.0;
	ptr[3] = src.m_c[7];
}
inline void mv::set(const vector &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = src.m_c[0];
	ptr[1] = src.m_c[1];
	ptr[2] = src.m_c[2];
	ptr[3] = src.m_c[3];
}
inline void mv::set(const vector3 &src) {
	setGroupUsage(2);
	double *ptr = m_c;
	ptr[0] = 0.0;
	ptr[1] = src.m_c[0];
	ptr[2] = src.m_c[1];
	ptr[3] = src.m_c[2];
}
inline void mv::set(const bivector &src) {
	setGroupUsage(4);
	double *ptr = m_c;
	ptr[0] = src.m_c[0];
	ptr[1] = src.m_c[1];
	ptr[2] = src.m_c[3];
	ptr[3] = src.m_c[2];
	ptr[4] = src.m_c[4];
	ptr[5] = src.m_c[5];
}
inline void mv::set(const bivector3 &src) {
	setGroupUsage(4);
	double *ptr = m_c;
	ptr[0] = ptr[1] = ptr[3] = 0.0;
	ptr[2] = src.m_c[0];
	ptr[4] = src.m_c[1];
	ptr[5] = src.m_c[2];
}
inline void mv::set(const pseudovector &src) {
	setGroupUsage(8);
	double *ptr = m_c;
	ptr[0] = src.m_c[0];
	ptr[1] = src.m_c[1];
	ptr[2] = src.m_c[2];
	ptr[3] = src.m_c[3];
}
inline void mv::set(const spinor &src) {
	setGroupUsage(21);
	double *ptr = m_c;
	ptr[0] = src.m_c[0];
	ptr += 1;
	ptr[0] = src.m_c[1];
	ptr[1] = src.m_c[2];
	ptr[2] = src.m_c[4];
	ptr[3] = src.m_c[3];
	ptr[4] = src.m_c[5];
	ptr[5] = src.m_c[6];
	ptr += 6;
	ptr[0] = src.m_c[7];
}
inline void mv::set(const spinor3 &src) {
	setGroupUsage(5);
	double *ptr = m_c;
	ptr[0] = src.m_c[0];
	ptr += 1;
	ptr[0] = ptr[1] = ptr[3] = 0.0;
	ptr[2] = src.m_c[1];
	ptr[4] = src.m_c[2];
	ptr[5] = src.m_c[3];
}

inline double _double(const mv &x) {
	return ((x.gu() & 1) != 0) ? x.getC()[0] : 0.0;
}

inline void mv3::set()
{
	m_c[0] = m_c[1] = m_c[2] = m_c[3] = m_c[4] = m_c[5] = m_c[6] = m_c[7] = 0.0;

}
inline void vector::set()
{
	m_c[0] = m_c[1] = m_c[2] = m_c[3] = 0.0;

}
inline void vector3::set()
{
	m_c[0] = m_c[1] = m_c[2] = 0.0;

}
inline void bivector::set()
{
	m_c[0] = m_c[1] = m_c[2] = m_c[3] = m_c[4] = m_c[5] = 0.0;

}
inline void bivector3::set()
{
	m_c[0] = m_c[1] = m_c[2] = 0.0;

}
inline void pseudovector::set()
{
	m_c[0] = m_c[1] = m_c[2] = m_c[3] = 0.0;

}
inline void spinor::set()
{
	m_c[0] = m_c[1] = m_c[2] = m_c[3] = m_c[4] = m_c[5] = m_c[6] = m_c[7] = 0.0;

}
inline void spinor3::set()
{
	m_c[0] = m_c[1] = m_c[2] = m_c[3] = 0.0;

}

inline void mv3::set(const double scalarVal)
{
	m_c[0] = scalarVal;
	m_c[1] = m_c[2] = m_c[3] = m_c[4] = m_c[5] = m_c[6] = m_c[7] = 0.0;

}
inline void spinor::set(const double scalarVal)
{
	m_c[0] = scalarVal;
	m_c[1] = m_c[2] = m_c[3] = m_c[4] = m_c[5] = m_c[6] = m_c[7] = 0.0;

}
inline void spinor3::set(const double scalarVal)
{
	m_c[0] = scalarVal;
	m_c[1] = m_c[2] = m_c[3] = 0.0;

}

inline void mv3::set(const CoordinateOrder co, const double _scalar, const double _g1, const double _g2, const double _g3, const double _g1_g2, const double _g1_g3, const double _g2_g3, const double _g1_g2_g3)
{
	m_c[0] = _scalar;
	m_c[1] = _g1;
	m_c[2] = _g2;
	m_c[3] = _g3;
	m_c[4] = _g1_g2;
	m_c[5] = _g1_g3;
	m_c[6] = _g2_g3;
	m_c[7] = _g1_g2_g3;

}
inline void vector::set(const CoordinateOrder co, const double _g0, const double _g1, const double _g2, const double _g3)
{
	m_c[0] = _g0;
	m_c[1] = _g1;
	m_c[2] = _g2;
	m_c[3] = _g3;

}
inline void vector3::set(const CoordinateOrder co, const double _g1, const double _g2, const double _g3)
{
	m_c[0] = _g1;
	m_c[1] = _g2;
	m_c[2] = _g3;

}
inline void bivector::set(const CoordinateOrder co, const double _g0_g1, const double _g0_g2, const double _g0_g3, const double _g1_g2, const double _g1_g3, const double _g2_g3)
{
	m_c[0] = _g0_g1;
	m_c[1] = _g0_g2;
	m_c[2] = _g0_g3;
	m_c[3] = _g1_g2;
	m_c[4] = _g1_g3;
	m_c[5] = _g2_g3;

}
inline void bivector3::set(const CoordinateOrder co, const double _g1_g2, const double _g1_g3, const double _g2_g3)
{
	m_c[0] = _g1_g2;
	m_c[1] = _g1_g3;
	m_c[2] = _g2_g3;

}
inline void pseudovector::set(const CoordinateOrder co, const double _g0_g1_g2, const double _g0_g1_g3, const double _g0_g2_g3, const double _g1_g2_g3)
{
	m_c[0] = _g0_g1_g2;
	m_c[1] = _g0_g1_g3;
	m_c[2] = _g0_g2_g3;
	m_c[3] = _g1_g2_g3;

}
inline void spinor::set(const CoordinateOrder co, const double _scalar, const double _g0_g1, const double _g0_g2, const double _g0_g3, const double _g1_g2, const double _g1_g3, const double _g2_g3, const double _g0_g1_g2_g3)
{
	m_c[0] = _scalar;
	m_c[1] = _g0_g1;
	m_c[2] = _g0_g2;
	m_c[3] = _g0_g3;
	m_c[4] = _g1_g2;
	m_c[5] = _g1_g3;
	m_c[6] = _g2_g3;
	m_c[7] = _g0_g1_g2_g3;

}
inline void spinor3::set(const CoordinateOrder co, const double _scalar, const double _g1_g2, const double _g1_g3, const double _g2_g3)
{
	m_c[0] = _scalar;
	m_c[1] = _g1_g2;
	m_c[2] = _g1_g3;
	m_c[3] = _g2_g3;

}

inline void mv3::set(const CoordinateOrder co, const double *A)
{
	m_c[0] = A[0];
	m_c[1] = A[1];
	m_c[2] = A[2];
	m_c[3] = A[3];
	m_c[4] = A[4];
	m_c[5] = A[5];
	m_c[6] = A[6];
	m_c[7] = A[7];

}
inline void vector::set(const CoordinateOrder co, const double *A)
{
	m_c[0] = A[0];
	m_c[1] = A[1];
	m_c[2] = A[2];
	m_c[3] = A[3];

}
inline void vector3::set(const CoordinateOrder co, const double *A)
{
	m_c[0] = A[0];
	m_c[1] = A[1];
	m_c[2] = A[2];

}
inline void bivector::set(const CoordinateOrder co, const double *A)
{
	m_c[0] = A[0];
	m_c[1] = A[1];
	m_c[2] = A[2];
	m_c[3] = A[3];
	m_c[4] = A[4];
	m_c[5] = A[5];

}
inline void bivector3::set(const CoordinateOrder co, const double *A)
{
	m_c[0] = A[0];
	m_c[1] = A[1];
	m_c[2] = A[2];

}
inline void pseudovector::set(const CoordinateOrder co, const double *A)
{
	m_c[0] = A[0];
	m_c[1] = A[1];
	m_c[2] = A[2];
	m_c[3] = A[3];

}
inline void spinor::set(const CoordinateOrder co, const double *A)
{
	m_c[0] = A[0];
	m_c[1] = A[1];
	m_c[2] = A[2];
	m_c[3] = A[3];
	m_c[4] = A[4];
	m_c[5] = A[5];
	m_c[6] = A[6];
	m_c[7] = A[7];

}
inline void spinor3::set(const CoordinateOrder co, const double *A)
{
	m_c[0] = A[0];
	m_c[1] = A[1];
	m_c[2] = A[2];
	m_c[3] = A[3];

}

inline void g0_t::set(const g0_t &a)
{

}
inline void g1_t::set(const g1_t &a)
{

}
inline void g2_t::set(const g2_t &a)
{

}
inline void g3_t::set(const g3_t &a)
{

}
inline void I_t::set(const I_t &a)
{

}
inline void I3_t::set(const I3_t &a)
{

}
inline void mv3::set(const mv3 &a)
{
	m_c[0] = a.m_c[0];
	m_c[1] = a.m_c[1];
	m_c[2] = a.m_c[2];
	m_c[3] = a.m_c[3];
	m_c[4] = a.m_c[4];
	m_c[5] = a.m_c[5];
	m_c[6] = a.m_c[6];
	m_c[7] = a.m_c[7];

}
inline void vector::set(const vector &a)
{
	m_c[0] = a.m_c[0];
	m_c[1] = a.m_c[1];
	m_c[2] = a.m_c[2];
	m_c[3] = a.m_c[3];

}
inline void vector3::set(const vector3 &a)
{
	m_c[0] = a.m_c[0];
	m_c[1] = a.m_c[1];
	m_c[2] = a.m_c[2];

}
inline void bivector::set(const bivector &a)
{
	m_c[0] = a.m_c[0];
	m_c[1] = a.m_c[1];
	m_c[2] = a.m_c[2];
	m_c[3] = a.m_c[3];
	m_c[4] = a.m_c[4];
	m_c[5] = a.m_c[5];

}
inline void bivector3::set(const bivector3 &a)
{
	m_c[0] = a.m_c[0];
	m_c[1] = a.m_c[1];
	m_c[2] = a.m_c[2];

}
inline void pseudovector::set(const pseudovector &a)
{
	m_c[0] = a.m_c[0];
	m_c[1] = a.m_c[1];
	m_c[2] = a.m_c[2];
	m_c[3] = a.m_c[3];

}
inline void spinor::set(const spinor &a)
{
	m_c[0] = a.m_c[0];
	m_c[1] = a.m_c[1];
	m_c[2] = a.m_c[2];
	m_c[3] = a.m_c[3];
	m_c[4] = a.m_c[4];
	m_c[5] = a.m_c[5];
	m_c[6] = a.m_c[6];
	m_c[7] = a.m_c[7];

}
inline void spinor3::set(const spinor3 &a)
{
	m_c[0] = a.m_c[0];
	m_c[1] = a.m_c[1];
	m_c[2] = a.m_c[2];
	m_c[3] = a.m_c[3];

}


inline double g0_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double g0_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 1;
	return maxValue;
}
inline double g1_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double g1_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 2;
	return maxValue;
}
inline double g2_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double g2_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 4;
	return maxValue;
}
inline double g3_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double g3_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 8;
	return maxValue;
}
inline double I_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double I_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 15;
	return maxValue;
}
inline double I3_t::largestCoordinate() const {
	double maxValue = 1.0;
	return maxValue;
}
inline double I3_t::largestBasisBlade(unsigned int &bm) const {
	double maxValue = 1.0;
	bm = 14;
	return maxValue;
}
inline double mv3::largestCoordinate() const {
	double maxValue = ::fabs(m_c[0]);
	if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); }
	if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); }
	if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); }
	if (::fabs(m_c[4]) > maxValue) { maxValue = ::fabs(m_c[4]); }
	if (::fabs(m_c[5]) > maxValue) { maxValue = ::fabs(m_c[5]); }
	if (::fabs(m_c[6]) > maxValue) { maxValue = ::fabs(m_c[6]); }
	if (::fabs(m_c[7]) > maxValue) { maxValue = ::fabs(m_c[7]); }
	return maxValue;
}
inline double mv3::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_c[0]);
	bm = 0;
	if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); bm = 2; }
	if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); bm = 4; }
	if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); bm = 8; }
	if (::fabs(m_c[4]) > maxValue) { maxValue = ::fabs(m_c[4]); bm = 6; }
	if (::fabs(m_c[5]) > maxValue) { maxValue = ::fabs(m_c[5]); bm = 10; }
	if (::fabs(m_c[6]) > maxValue) { maxValue = ::fabs(m_c[6]); bm = 12; }
	if (::fabs(m_c[7]) > maxValue) { maxValue = ::fabs(m_c[7]); bm = 14; }
	return maxValue;
}
inline double vector::largestCoordinate() const {
	double maxValue = ::fabs(m_c[0]);
	if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); }
	if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); }
	if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); }
	return maxValue;
}
inline double vector::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_c[0]);
	bm = 0;
	if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); bm = 2; }
	if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); bm = 4; }
	if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); bm = 8; }
	return maxValue;
}
inline double vector3::largestCoordinate() const {
	double maxValue = ::fabs(m_c[0]);
	if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); }
	if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); }
	return maxValue;
}
inline double vector3::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_c[0]);
	bm = 0;
	if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); bm = 4; }
	if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); bm = 8; }
	return maxValue;
}
inline double bivector::largestCoordinate() const {
	double maxValue = ::fabs(m_c[0]);
	if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); }
	if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); }
	if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); }
	if (::fabs(m_c[4]) > maxValue) { maxValue = ::fabs(m_c[4]); }
	if (::fabs(m_c[5]) > maxValue) { maxValue = ::fabs(m_c[5]); }
	return maxValue;
}
inline double bivector::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_c[0]);
	bm = 0;
	if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); bm = 5; }
	if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); bm = 9; }
	if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); bm = 6; }
	if (::fabs(m_c[4]) > maxValue) { maxValue = ::fabs(m_c[4]); bm = 10; }
	if (::fabs(m_c[5]) > maxValue) { maxValue = ::fabs(m_c[5]); bm = 12; }
	return maxValue;
}
inline double bivector3::largestCoordinate() const {
	double maxValue = ::fabs(m_c[0]);
	if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); }
	if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); }
	return maxValue;
}
inline double bivector3::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_c[0]);
	bm = 0;
	if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); bm = 10; }
	if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); bm = 12; }
	return maxValue;
}
inline double pseudovector::largestCoordinate() const {
	double maxValue = ::fabs(m_c[0]);
	if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); }
	if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); }
	if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); }
	return maxValue;
}
inline double pseudovector::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_c[0]);
	bm = 0;
	if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); bm = 11; }
	if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); bm = 13; }
	if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); bm = 14; }
	return maxValue;
}
inline double spinor::largestCoordinate() const {
	double maxValue = ::fabs(m_c[0]);
	if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); }
	if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); }
	if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); }
	if (::fabs(m_c[4]) > maxValue) { maxValue = ::fabs(m_c[4]); }
	if (::fabs(m_c[5]) > maxValue) { maxValue = ::fabs(m_c[5]); }
	if (::fabs(m_c[6]) > maxValue) { maxValue = ::fabs(m_c[6]); }
	if (::fabs(m_c[7]) > maxValue) { maxValue = ::fabs(m_c[7]); }
	return maxValue;
}
inline double spinor::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_c[0]);
	bm = 0;
	if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); bm = 3; }
	if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); bm = 5; }
	if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); bm = 9; }
	if (::fabs(m_c[4]) > maxValue) { maxValue = ::fabs(m_c[4]); bm = 6; }
	if (::fabs(m_c[5]) > maxValue) { maxValue = ::fabs(m_c[5]); bm = 10; }
	if (::fabs(m_c[6]) > maxValue) { maxValue = ::fabs(m_c[6]); bm = 12; }
	if (::fabs(m_c[7]) > maxValue) { maxValue = ::fabs(m_c[7]); bm = 15; }
	return maxValue;
}
inline double spinor3::largestCoordinate() const {
	double maxValue = ::fabs(m_c[0]);
	if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); }
	if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); }
	if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); }
	return maxValue;
}
inline double spinor3::largestBasisBlade(unsigned int &bm) const {
	double maxValue = ::fabs(m_c[0]);
	bm = 0;
	if (::fabs(m_c[1]) > maxValue) { maxValue = ::fabs(m_c[1]); bm = 6; }
	if (::fabs(m_c[2]) > maxValue) { maxValue = ::fabs(m_c[2]); bm = 10; }
	if (::fabs(m_c[3]) > maxValue) { maxValue = ::fabs(m_c[3]); bm = 12; }
	return maxValue;
}

inline double _double(const g0_t &x) {
	return 0.0;
}
inline double _double(const g1_t &x) {
	return 0.0;
}
inline double _double(const g2_t &x) {
	return 0.0;
}
inline double _double(const g3_t &x) {
	return 0.0;
}
inline double _double(const I_t &x) {
	return 0.0;
}
inline double _double(const I3_t &x) {
	return 0.0;
}
inline double _double(const mv3 &x) {
	return x.m_c[0];
}
inline double _double(const vector &x) {
	return 0.0;
}
inline double _double(const vector3 &x) {
	return 0.0;
}
inline double _double(const bivector &x) {
	return 0.0;
}
inline double _double(const bivector3 &x) {
	return 0.0;
}
inline double _double(const pseudovector &x) {
	return 0.0;
}
inline double _double(const spinor &x) {
	return x.m_c[0];
}
inline double _double(const spinor3 &x) {
	return x.m_c[0];
}
inline vector3 _vector3(const vector &a)
{
	return vector3(vector3::coord_g1_g2_g3,
			a.m_c[1], // g1
			a.m_c[2], // g2
			a.m_c[3] // g3
		);

}
inline bivector3 _bivector3(const bivector &a)
{
	return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
			a.m_c[3], // g1_g2
			a.m_c[4], // g1_g3
			a.m_c[5] // g2_g3
		);

}
inline spinor3 _spinor3(const spinor &a)
{
	return spinor3(spinor3::coord_scalar_g1g2_g1g3_g2g3,
			a.m_c[0], // scalar
			a.m_c[4], // g1_g2
			a.m_c[5], // g1_g3
			a.m_c[6] // g2_g3
		);

}
inline double extractGrade0(const mv3 &a)
{
	return a.m_c[0];
}
inline double extractGrade0(const vector &a)
{
	return 0.0;
}
inline double extractGrade0(const vector3 &a)
{
	return 0.0;
}
inline double extractGrade0(const bivector &a)
{
	return 0.0;
}
inline double extractGrade0(const bivector3 &a)
{
	return 0.0;
}
inline double extractGrade0(const pseudovector &a)
{
	return 0.0;
}
inline double extractGrade0(const spinor &a)
{
	return a.m_c[0];
}
inline double extractGrade0(const spinor3 &a)
{
	return a.m_c[0];
}
inline vector3 extractGrade1(const mv3 &a)
{
	return vector3(vector3::coord_g1_g2_g3,
			a.m_c[1], // g1
			a.m_c[2], // g2
			a.m_c[3] // g3
		);
}
inline vector extractGrade1(const vector &a)
{
	return vector(vector::coord_g0_g1_g2_g3,
			a.m_c[0], // g0
			a.m_c[1], // g1
			a.m_c[2], // g2
			a.m_c[3] // g3
		);
}
inline vector3 extractGrade1(const vector3 &a)
{
	return vector3(vector3::coord_g1_g2_g3,
			a.m_c[0], // g1
			a.m_c[1], // g2
			a.m_c[2] // g3
		);
}
inline double extractGrade1(const bivector &a)
{
	return 0.0;
}
inline double extractGrade1(const bivector3 &a)
{
	return 0.0;
}
inline double extractGrade1(const pseudovector &a)
{
	return 0.0;
}
inline double extractGrade1(const spinor &a)
{
	return 0.0;
}
inline double extractGrade1(const spinor3 &a)
{
	return 0.0;
}
inline bivector3 extractGrade2(const mv3 &a)
{
	return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
			a.m_c[4], // g1_g2
			a.m_c[5], // g1_g3
			a.m_c[6] // g2_g3
		);
}
inline double extractGrade2(const vector &a)
{
	return 0.0;
}
inline double extractGrade2(const vector3 &a)
{
	return 0.0;
}
inline bivector extractGrade2(const bivector &a)
{
	return bivector(bivector::coord_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3,
			a.m_c[0], // g0_g1
			a.m_c[1], // g0_g2
			a.m_c[2], // g0_g3
			a.m_c[3], // g1_g2
			a.m_c[4], // g1_g3
			a.m_c[5] // g2_g3
		);
}
inline bivector3 extractGrade2(const bivector3 &a)
{
	return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
			a.m_c[0], // g1_g2
			a.m_c[1], // g1_g3
			a.m_c[2] // g2_g3
		);
}
inline double extractGrade2(const pseudovector &a)
{
	return 0.0;
}
inline bivector extractGrade2(const spinor &a)
{
	return bivector(bivector::coord_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3,
			a.m_c[1], // g0_g1
			a.m_c[2], // g0_g2
			a.m_c[3], // g0_g3
			a.m_c[4], // g1_g2
			a.m_c[5], // g1_g3
			a.m_c[6] // g2_g3
		);
}
inline bivector3 extractGrade2(const spinor3 &a)
{
	return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
			a.m_c[1], // g1_g2
			a.m_c[2], // g1_g3
			a.m_c[3] // g2_g3
		);
}
inline pseudovector extractGrade3(const mv3 &a)
{
	return pseudovector(pseudovector::coord_g0g1g2_g0g1g3_g0g2g3_g1g2g3,
			0.0, // g0_g1_g2
			0.0, // g0_g1_g3
			0.0, // g0_g2_g3
			a.m_c[7] // g1_g2_g3
		);
}
inline double extractGrade3(const vector &a)
{
	return 0.0;
}
inline double extractGrade3(const vector3 &a)
{
	return 0.0;
}
inline double extractGrade3(const bivector &a)
{
	return 0.0;
}
inline double extractGrade3(const bivector3 &a)
{
	return 0.0;
}
inline pseudovector extractGrade3(const pseudovector &a)
{
	return pseudovector(pseudovector::coord_g0g1g2_g0g1g3_g0g2g3_g1g2g3,
			a.m_c[0], // g0_g1_g2
			a.m_c[1], // g0_g1_g3
			a.m_c[2], // g0_g2_g3
			a.m_c[3] // g1_g2_g3
		);
}
inline double extractGrade3(const spinor &a)
{
	return 0.0;
}
inline double extractGrade3(const spinor3 &a)
{
	return 0.0;
}
inline double extractGrade4(const mv3 &a)
{
	return 0.0;
}
inline double extractGrade4(const vector &a)
{
	return 0.0;
}
inline double extractGrade4(const vector3 &a)
{
	return 0.0;
}
inline double extractGrade4(const bivector &a)
{
	return 0.0;
}
inline double extractGrade4(const bivector3 &a)
{
	return 0.0;
}
inline double extractGrade4(const pseudovector &a)
{
	return 0.0;
}
inline spinor extractGrade4(const spinor &a)
{
	return spinor(spinor::coord_scalar_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3_g0g1g2g3,
			0.0, // scalar
			0.0, // g0_g1
			0.0, // g0_g2
			0.0, // g0_g3
			0.0, // g1_g2
			0.0, // g1_g3
			0.0, // g2_g3
			a.m_c[7] // g0_g1_g2_g3
		);
}
inline double extractGrade4(const spinor3 &a)
{
	return 0.0;
}
inline mv3 add(const mv3 &a, const mv3 &b)
{
	return mv3(mv3::coord_scalar_g1_g2_g3_g1g2_g1g3_g2g3_g1g2g3,
			(a.m_c[0]+b.m_c[0]), // scalar
			(a.m_c[1]+b.m_c[1]), // g1
			(a.m_c[2]+b.m_c[2]), // g2
			(a.m_c[3]+b.m_c[3]), // g3
			(a.m_c[4]+b.m_c[4]), // g1_g2
			(a.m_c[5]+b.m_c[5]), // g1_g3
			(a.m_c[6]+b.m_c[6]), // g2_g3
			(a.m_c[7]+b.m_c[7]) // g1_g2_g3
		);

}
inline vector add(const vector &a, const vector &b)
{
	return vector(vector::coord_g0_g1_g2_g3,
			(a.m_c[0]+b.m_c[0]), // g0
			(a.m_c[1]+b.m_c[1]), // g1
			(a.m_c[2]+b.m_c[2]), // g2
			(a.m_c[3]+b.m_c[3]) // g3
		);

}
inline vector3 add(const vector3 &a, const vector3 &b)
{
	return vector3(vector3::coord_g1_g2_g3,
			(a.m_c[0]+b.m_c[0]), // g1
			(a.m_c[1]+b.m_c[1]), // g2
			(a.m_c[2]+b.m_c[2]) // g3
		);

}
inline bivector add(const bivector &a, const bivector &b)
{
	return bivector(bivector::coord_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3,
			(a.m_c[0]+b.m_c[0]), // g0_g1
			(a.m_c[1]+b.m_c[1]), // g0_g2
			(a.m_c[2]+b.m_c[2]), // g0_g3
			(a.m_c[3]+b.m_c[3]), // g1_g2
			(a.m_c[4]+b.m_c[4]), // g1_g3
			(a.m_c[5]+b.m_c[5]) // g2_g3
		);

}
inline bivector3 add(const bivector3 &a, const bivector3 &b)
{
	return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
			(a.m_c[0]+b.m_c[0]), // g1_g2
			(a.m_c[1]+b.m_c[1]), // g1_g3
			(a.m_c[2]+b.m_c[2]) // g2_g3
		);

}
inline pseudovector add(const pseudovector &a, const pseudovector &b)
{
	return pseudovector(pseudovector::coord_g0g1g2_g0g1g3_g0g2g3_g1g2g3,
			(a.m_c[0]+b.m_c[0]), // g0_g1_g2
			(a.m_c[1]+b.m_c[1]), // g0_g1_g3
			(a.m_c[2]+b.m_c[2]), // g0_g2_g3
			(a.m_c[3]+b.m_c[3]) // g1_g2_g3
		);

}
inline spinor add(const spinor &a, const spinor &b)
{
	return spinor(spinor::coord_scalar_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3_g0g1g2g3,
			(a.m_c[0]+b.m_c[0]), // scalar
			(a.m_c[1]+b.m_c[1]), // g0_g1
			(a.m_c[2]+b.m_c[2]), // g0_g2
			(a.m_c[3]+b.m_c[3]), // g0_g3
			(a.m_c[4]+b.m_c[4]), // g1_g2
			(a.m_c[5]+b.m_c[5]), // g1_g3
			(a.m_c[6]+b.m_c[6]), // g2_g3
			(a.m_c[7]+b.m_c[7]) // g0_g1_g2_g3
		);

}
inline spinor3 add(const spinor3 &a, const spinor3 &b)
{
	return spinor3(spinor3::coord_scalar_g1g2_g1g3_g2g3,
			(a.m_c[0]+b.m_c[0]), // scalar
			(a.m_c[1]+b.m_c[1]), // g1_g2
			(a.m_c[2]+b.m_c[2]), // g1_g3
			(a.m_c[3]+b.m_c[3]) // g2_g3
		);

}
inline mv3 subtract(const mv3 &a, const mv3 &b)
{
	return mv3(mv3::coord_scalar_g1_g2_g3_g1g2_g1g3_g2g3_g1g2g3,
			(a.m_c[0]-b.m_c[0]), // scalar
			(a.m_c[1]-b.m_c[1]), // g1
			(a.m_c[2]-b.m_c[2]), // g2
			(a.m_c[3]-b.m_c[3]), // g3
			(a.m_c[4]-b.m_c[4]), // g1_g2
			(a.m_c[5]-b.m_c[5]), // g1_g3
			(a.m_c[6]-b.m_c[6]), // g2_g3
			(a.m_c[7]-b.m_c[7]) // g1_g2_g3
		);

}
inline vector subtract(const vector &a, const vector &b)
{
	return vector(vector::coord_g0_g1_g2_g3,
			(a.m_c[0]-b.m_c[0]), // g0
			(a.m_c[1]-b.m_c[1]), // g1
			(a.m_c[2]-b.m_c[2]), // g2
			(a.m_c[3]-b.m_c[3]) // g3
		);

}
inline vector3 subtract(const vector3 &a, const vector3 &b)
{
	return vector3(vector3::coord_g1_g2_g3,
			(a.m_c[0]-b.m_c[0]), // g1
			(a.m_c[1]-b.m_c[1]), // g2
			(a.m_c[2]-b.m_c[2]) // g3
		);

}
inline bivector subtract(const bivector &a, const bivector &b)
{
	return bivector(bivector::coord_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3,
			(a.m_c[0]-b.m_c[0]), // g0_g1
			(a.m_c[1]-b.m_c[1]), // g0_g2
			(a.m_c[2]-b.m_c[2]), // g0_g3
			(a.m_c[3]-b.m_c[3]), // g1_g2
			(a.m_c[4]-b.m_c[4]), // g1_g3
			(a.m_c[5]-b.m_c[5]) // g2_g3
		);

}
inline bivector3 subtract(const bivector3 &a, const bivector3 &b)
{
	return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
			(a.m_c[0]-b.m_c[0]), // g1_g2
			(a.m_c[1]-b.m_c[1]), // g1_g3
			(a.m_c[2]-b.m_c[2]) // g2_g3
		);

}
inline pseudovector subtract(const pseudovector &a, const pseudovector &b)
{
	return pseudovector(pseudovector::coord_g0g1g2_g0g1g3_g0g2g3_g1g2g3,
			(a.m_c[0]-b.m_c[0]), // g0_g1_g2
			(a.m_c[1]-b.m_c[1]), // g0_g1_g3
			(a.m_c[2]-b.m_c[2]), // g0_g2_g3
			(a.m_c[3]-b.m_c[3]) // g1_g2_g3
		);

}
inline spinor subtract(const spinor &a, const spinor &b)
{
	return spinor(spinor::coord_scalar_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3_g0g1g2g3,
			(a.m_c[0]-b.m_c[0]), // scalar
			(a.m_c[1]-b.m_c[1]), // g0_g1
			(a.m_c[2]-b.m_c[2]), // g0_g2
			(a.m_c[3]-b.m_c[3]), // g0_g3
			(a.m_c[4]-b.m_c[4]), // g1_g2
			(a.m_c[5]-b.m_c[5]), // g1_g3
			(a.m_c[6]-b.m_c[6]), // g2_g3
			(a.m_c[7]-b.m_c[7]) // g0_g1_g2_g3
		);

}
inline spinor3 subtract(const spinor3 &a, const spinor3 &b)
{
	return spinor3(spinor3::coord_scalar_g1g2_g1g3_g2g3,
			(a.m_c[0]-b.m_c[0]), // scalar
			(a.m_c[1]-b.m_c[1]), // g1_g2
			(a.m_c[2]-b.m_c[2]), // g1_g3
			(a.m_c[3]-b.m_c[3]) // g2_g3
		);

}
inline mv3 gp(const double a, const mv3 &b)
{
	return mv3(mv3::coord_scalar_g1_g2_g3_g1g2_g1g3_g2g3_g1g2g3,
			a*b.m_c[0], // scalar
			a*b.m_c[1], // g1
			a*b.m_c[2], // g2
			a*b.m_c[3], // g3
			a*b.m_c[4], // g1_g2
			a*b.m_c[5], // g1_g3
			a*b.m_c[6], // g2_g3
			a*b.m_c[7] // g1_g2_g3
		);

}
inline vector gp(const double a, const vector &b)
{
	return vector(vector::coord_g0_g1_g2_g3,
			a*b.m_c[0], // g0
			a*b.m_c[1], // g1
			a*b.m_c[2], // g2
			a*b.m_c[3] // g3
		);

}
inline vector3 gp(const double a, const vector3 &b)
{
	return vector3(vector3::coord_g1_g2_g3,
			a*b.m_c[0], // g1
			a*b.m_c[1], // g2
			a*b.m_c[2] // g3
		);

}
inline bivector gp(const double a, const bivector &b)
{
	return bivector(bivector::coord_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3,
			a*b.m_c[0], // g0_g1
			a*b.m_c[1], // g0_g2
			a*b.m_c[2], // g0_g3
			a*b.m_c[3], // g1_g2
			a*b.m_c[4], // g1_g3
			a*b.m_c[5] // g2_g3
		);

}
inline bivector3 gp(const double a, const bivector3 &b)
{
	return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
			a*b.m_c[0], // g1_g2
			a*b.m_c[1], // g1_g3
			a*b.m_c[2] // g2_g3
		);

}
inline pseudovector gp(const double a, const pseudovector &b)
{
	return pseudovector(pseudovector::coord_g0g1g2_g0g1g3_g0g2g3_g1g2g3,
			a*b.m_c[0], // g0_g1_g2
			a*b.m_c[1], // g0_g1_g3
			a*b.m_c[2], // g0_g2_g3
			a*b.m_c[3] // g1_g2_g3
		);

}
inline spinor gp(const double a, const spinor &b)
{
	return spinor(spinor::coord_scalar_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3_g0g1g2g3,
			a*b.m_c[0], // scalar
			a*b.m_c[1], // g0_g1
			a*b.m_c[2], // g0_g2
			a*b.m_c[3], // g0_g3
			a*b.m_c[4], // g1_g2
			a*b.m_c[5], // g1_g3
			a*b.m_c[6], // g2_g3
			a*b.m_c[7] // g0_g1_g2_g3
		);

}
inline spinor3 gp(const double a, const spinor3 &b)
{
	return spinor3(spinor3::coord_scalar_g1g2_g1g3_g2g3,
			a*b.m_c[0], // scalar
			a*b.m_c[1], // g1_g2
			a*b.m_c[2], // g1_g3
			a*b.m_c[3] // g2_g3
		);

}
inline mv3 gp(const mv3 &a, const double b)
{
	return mv3(mv3::coord_scalar_g1_g2_g3_g1g2_g1g3_g2g3_g1g2g3,
			a.m_c[0]*b, // scalar
			a.m_c[1]*b, // g1
			a.m_c[2]*b, // g2
			a.m_c[3]*b, // g3
			a.m_c[4]*b, // g1_g2
			a.m_c[5]*b, // g1_g3
			a.m_c[6]*b, // g2_g3
			a.m_c[7]*b // g1_g2_g3
		);

}
inline vector gp(const vector &a, const double b)
{
	return vector(vector::coord_g0_g1_g2_g3,
			a.m_c[0]*b, // g0
			a.m_c[1]*b, // g1
			a.m_c[2]*b, // g2
			a.m_c[3]*b // g3
		);

}
inline vector3 gp(const vector3 &a, const double b)
{
	return vector3(vector3::coord_g1_g2_g3,
			a.m_c[0]*b, // g1
			a.m_c[1]*b, // g2
			a.m_c[2]*b // g3
		);

}
inline bivector gp(const bivector &a, const double b)
{
	return bivector(bivector::coord_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3,
			a.m_c[0]*b, // g0_g1
			a.m_c[1]*b, // g0_g2
			a.m_c[2]*b, // g0_g3
			a.m_c[3]*b, // g1_g2
			a.m_c[4]*b, // g1_g3
			a.m_c[5]*b // g2_g3
		);

}
inline bivector3 gp(const bivector3 &a, const double b)
{
	return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
			a.m_c[0]*b, // g1_g2
			a.m_c[1]*b, // g1_g3
			a.m_c[2]*b // g2_g3
		);

}
inline pseudovector gp(const pseudovector &a, const double b)
{
	return pseudovector(pseudovector::coord_g0g1g2_g0g1g3_g0g2g3_g1g2g3,
			a.m_c[0]*b, // g0_g1_g2
			a.m_c[1]*b, // g0_g1_g3
			a.m_c[2]*b, // g0_g2_g3
			a.m_c[3]*b // g1_g2_g3
		);

}
inline spinor gp(const spinor &a, const double b)
{
	return spinor(spinor::coord_scalar_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3_g0g1g2g3,
			a.m_c[0]*b, // scalar
			a.m_c[1]*b, // g0_g1
			a.m_c[2]*b, // g0_g2
			a.m_c[3]*b, // g0_g3
			a.m_c[4]*b, // g1_g2
			a.m_c[5]*b, // g1_g3
			a.m_c[6]*b, // g2_g3
			a.m_c[7]*b // g0_g1_g2_g3
		);

}
inline spinor3 gp(const spinor3 &a, const double b)
{
	return spinor3(spinor3::coord_scalar_g1g2_g1g3_g2g3,
			a.m_c[0]*b, // scalar
			a.m_c[1]*b, // g1_g2
			a.m_c[2]*b, // g1_g3
			a.m_c[3]*b // g2_g3
		);

}
inline mv3 div(const mv3 &a, const double b)
{
	return mv3(mv3::coord_scalar_g1_g2_g3_g1g2_g1g3_g2g3_g1g2g3,
			a.m_c[0]/((b)), // scalar
			a.m_c[1]/((b)), // g1
			a.m_c[2]/((b)), // g2
			a.m_c[3]/((b)), // g3
			a.m_c[4]/((b)), // g1_g2
			a.m_c[5]/((b)), // g1_g3
			a.m_c[6]/((b)), // g2_g3
			a.m_c[7]/((b)) // g1_g2_g3
		);
}
inline vector div(const vector &a, const double b)
{
	return vector(vector::coord_g0_g1_g2_g3,
			a.m_c[0]/((b)), // g0
			a.m_c[1]/((b)), // g1
			a.m_c[2]/((b)), // g2
			a.m_c[3]/((b)) // g3
		);
}
inline vector3 div(const vector3 &a, const double b)
{
	return vector3(vector3::coord_g1_g2_g3,
			a.m_c[0]/((b)), // g1
			a.m_c[1]/((b)), // g2
			a.m_c[2]/((b)) // g3
		);
}
inline bivector div(const bivector &a, const double b)
{
	return bivector(bivector::coord_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3,
			a.m_c[0]/((b)), // g0_g1
			a.m_c[1]/((b)), // g0_g2
			a.m_c[2]/((b)), // g0_g3
			a.m_c[3]/((b)), // g1_g2
			a.m_c[4]/((b)), // g1_g3
			a.m_c[5]/((b)) // g2_g3
		);
}
inline bivector3 div(const bivector3 &a, const double b)
{
	return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
			a.m_c[0]/((b)), // g1_g2
			a.m_c[1]/((b)), // g1_g3
			a.m_c[2]/((b)) // g2_g3
		);
}
inline pseudovector div(const pseudovector &a, const double b)
{
	return pseudovector(pseudovector::coord_g0g1g2_g0g1g3_g0g2g3_g1g2g3,
			a.m_c[0]/((b)), // g0_g1_g2
			a.m_c[1]/((b)), // g0_g1_g3
			a.m_c[2]/((b)), // g0_g2_g3
			a.m_c[3]/((b)) // g1_g2_g3
		);
}
inline spinor div(const spinor &a, const double b)
{
	return spinor(spinor::coord_scalar_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3_g0g1g2g3,
			a.m_c[0]/((b)), // scalar
			a.m_c[1]/((b)), // g0_g1
			a.m_c[2]/((b)), // g0_g2
			a.m_c[3]/((b)), // g0_g3
			a.m_c[4]/((b)), // g1_g2
			a.m_c[5]/((b)), // g1_g3
			a.m_c[6]/((b)), // g2_g3
			a.m_c[7]/((b)) // g0_g1_g2_g3
		);
}
inline spinor3 div(const spinor3 &a, const double b)
{
	return spinor3(spinor3::coord_scalar_g1g2_g1g3_g2g3,
			a.m_c[0]/((b)), // scalar
			a.m_c[1]/((b)), // g1_g2
			a.m_c[2]/((b)), // g1_g3
			a.m_c[3]/((b)) // g2_g3
		);
}
inline spinor gp(const spinor &a, const spinor &b)
{
	return spinor(spinor::coord_scalar_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3_g0g1g2g3,
			(a.m_c[0]*b.m_c[0]+a.m_c[1]*b.m_c[1]+a.m_c[2]*b.m_c[2]+a.m_c[3]*b.m_c[3]-a.m_c[4]*b.m_c[4]-a.m_c[5]*b.m_c[5]-a.m_c[6]*b.m_c[6]-a.m_c[7]*b.m_c[7]), // scalar
			(a.m_c[0]*b.m_c[1]+a.m_c[1]*b.m_c[0]+a.m_c[2]*b.m_c[4]+a.m_c[3]*b.m_c[5]-a.m_c[4]*b.m_c[2]-a.m_c[5]*b.m_c[3]-a.m_c[6]*b.m_c[7]-a.m_c[7]*b.m_c[6]), // g0_g1
			(a.m_c[0]*b.m_c[2]-a.m_c[1]*b.m_c[4]+a.m_c[2]*b.m_c[0]+a.m_c[3]*b.m_c[6]+a.m_c[4]*b.m_c[1]+a.m_c[5]*b.m_c[7]-a.m_c[6]*b.m_c[3]+a.m_c[7]*b.m_c[5]), // g0_g2
			(a.m_c[0]*b.m_c[3]-a.m_c[1]*b.m_c[5]-a.m_c[2]*b.m_c[6]+a.m_c[3]*b.m_c[0]-a.m_c[4]*b.m_c[7]+a.m_c[5]*b.m_c[1]+a.m_c[6]*b.m_c[2]-a.m_c[7]*b.m_c[4]), // g0_g3
			(a.m_c[0]*b.m_c[4]-a.m_c[1]*b.m_c[2]+a.m_c[2]*b.m_c[1]+a.m_c[3]*b.m_c[7]+a.m_c[4]*b.m_c[0]+a.m_c[5]*b.m_c[6]-a.m_c[6]*b.m_c[5]+a.m_c[7]*b.m_c[3]), // g1_g2
			(a.m_c[0]*b.m_c[5]-a.m_c[1]*b.m_c[3]-a.m_c[2]*b.m_c[7]+a.m_c[3]*b.m_c[1]-a.m_c[4]*b.m_c[6]+a.m_c[5]*b.m_c[0]+a.m_c[6]*b.m_c[4]-a.m_c[7]*b.m_c[2]), // g1_g3
			(a.m_c[0]*b.m_c[6]+a.m_c[1]*b.m_c[7]-a.m_c[2]*b.m_c[3]+a.m_c[3]*b.m_c[2]+a.m_c[4]*b.m_c[5]-a.m_c[5]*b.m_c[4]+a.m_c[6]*b.m_c[0]+a.m_c[7]*b.m_c[1]), // g2_g3
			(a.m_c[0]*b.m_c[7]+a.m_c[1]*b.m_c[6]-a.m_c[2]*b.m_c[5]+a.m_c[3]*b.m_c[4]+a.m_c[4]*b.m_c[3]-a.m_c[5]*b.m_c[2]+a.m_c[6]*b.m_c[1]+a.m_c[7]*b.m_c[0]) // g0_g1_g2_g3
		);

}
inline spinor3 gp(const spinor3 &a, const spinor3 &b)
{
	return spinor3(spinor3::coord_scalar_g1g2_g1g3_g2g3,
			(a.m_c[0]*b.m_c[0]-a.m_c[1]*b.m_c[1]-a.m_c[2]*b.m_c[2]-a.m_c[3]*b.m_c[3]), // scalar
			(a.m_c[0]*b.m_c[1]+a.m_c[1]*b.m_c[0]+a.m_c[2]*b.m_c[3]-a.m_c[3]*b.m_c[2]), // g1_g2
			(a.m_c[0]*b.m_c[2]-a.m_c[1]*b.m_c[3]+a.m_c[2]*b.m_c[0]+a.m_c[3]*b.m_c[1]), // g1_g3
			(a.m_c[0]*b.m_c[3]+a.m_c[1]*b.m_c[2]-a.m_c[2]*b.m_c[1]+a.m_c[3]*b.m_c[0]) // g2_g3
		);

}
inline double sp(const mv3 &a, const mv3 &b)
{
	return (a.m_c[0]*b.m_c[0]-a.m_c[1]*b.m_c[1]-a.m_c[2]*b.m_c[2]-a.m_c[3]*b.m_c[3]-a.m_c[4]*b.m_c[4]-a.m_c[5]*b.m_c[5]-a.m_c[6]*b.m_c[6]+a.m_c[7]*b.m_c[7]);

}
inline double sp(const vector &a, const vector &b)
{
	return (a.m_c[0]*b.m_c[0]-a.m_c[1]*b.m_c[1]-a.m_c[2]*b.m_c[2]-a.m_c[3]*b.m_c[3]);

}
inline double sp(const vector3 &a, const vector3 &b)
{
	return (-a.m_c[0]*b.m_c[0]-a.m_c[1]*b.m_c[1]-a.m_c[2]*b.m_c[2]);

}
inline double sp(const bivector &a, const bivector &b)
{
	return (a.m_c[0]*b.m_c[0]+a.m_c[1]*b.m_c[1]+a.m_c[2]*b.m_c[2]-a.m_c[3]*b.m_c[3]-a.m_c[4]*b.m_c[4]-a.m_c[5]*b.m_c[5]);

}
inline double sp(const bivector3 &a, const bivector3 &b)
{
	return (-a.m_c[0]*b.m_c[0]-a.m_c[1]*b.m_c[1]-a.m_c[2]*b.m_c[2]);

}
inline double sp(const pseudovector &a, const pseudovector &b)
{
	return (-a.m_c[0]*b.m_c[0]-a.m_c[1]*b.m_c[1]-a.m_c[2]*b.m_c[2]+a.m_c[3]*b.m_c[3]);

}
inline double sp(const spinor &a, const spinor &b)
{
	return (a.m_c[0]*b.m_c[0]+a.m_c[1]*b.m_c[1]+a.m_c[2]*b.m_c[2]+a.m_c[3]*b.m_c[3]-a.m_c[4]*b.m_c[4]-a.m_c[5]*b.m_c[5]-a.m_c[6]*b.m_c[6]-a.m_c[7]*b.m_c[7]);

}
inline double sp(const spinor3 &a, const spinor3 &b)
{
	return (a.m_c[0]*b.m_c[0]-a.m_c[1]*b.m_c[1]-a.m_c[2]*b.m_c[2]-a.m_c[3]*b.m_c[3]);

}
inline bivector op(const vector &a, const vector &b)
{
	return bivector(bivector::coord_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3,
			(a.m_c[0]*b.m_c[1]-a.m_c[1]*b.m_c[0]), // g0_g1
			(a.m_c[0]*b.m_c[2]-a.m_c[2]*b.m_c[0]), // g0_g2
			(a.m_c[0]*b.m_c[3]-a.m_c[3]*b.m_c[0]), // g0_g3
			(a.m_c[1]*b.m_c[2]-a.m_c[2]*b.m_c[1]), // g1_g2
			(a.m_c[1]*b.m_c[3]-a.m_c[3]*b.m_c[1]), // g1_g3
			(a.m_c[2]*b.m_c[3]-a.m_c[3]*b.m_c[2]) // g2_g3
		);

}
inline bivector3 op(const vector3 &a, const vector3 &b)
{
	return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
			(a.m_c[0]*b.m_c[1]-a.m_c[1]*b.m_c[0]), // g1_g2
			(a.m_c[0]*b.m_c[2]-a.m_c[2]*b.m_c[0]), // g1_g3
			(a.m_c[1]*b.m_c[2]-a.m_c[2]*b.m_c[1]) // g2_g3
		);

}
inline spinor op(const bivector &a, const bivector &b)
{
	return spinor(spinor::coord_scalar_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3_g0g1g2g3,
			0.0, // scalar
			0.0, // g0_g1
			0.0, // g0_g2
			0.0, // g0_g3
			0.0, // g1_g2
			0.0, // g1_g3
			0.0, // g2_g3
			(a.m_c[0]*b.m_c[5]-a.m_c[1]*b.m_c[4]+a.m_c[2]*b.m_c[3]+a.m_c[3]*b.m_c[2]-a.m_c[4]*b.m_c[1]+a.m_c[5]*b.m_c[0]) // g0_g1_g2_g3
		);

}
inline double op(const bivector3 &a, const bivector3 &b)
{
	return 0.0;

}
inline pseudovector dual(const vector &a)
{
	return pseudovector(pseudovector::coord_g0g1g2_g0g1g3_g0g2g3_g1g2g3,
			-a.m_c[3], // g0_g1_g2
			a.m_c[2], // g0_g1_g3
			-a.m_c[1], // g0_g2_g3
			-a.m_c[0] // g1_g2_g3
		);

}
inline bivector dual(const bivector &a)
{
	return bivector(bivector::coord_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3,
			a.m_c[5], // g0_g1
			-a.m_c[4], // g0_g2
			a.m_c[3], // g0_g3
			-a.m_c[2], // g1_g2
			a.m_c[1], // g1_g3
			-a.m_c[0] // g2_g3
		);

}
inline vector dual(const pseudovector &a)
{
	return vector(vector::coord_g0_g1_g2_g3,
			a.m_c[3], // g0
			a.m_c[2], // g1
			-a.m_c[1], // g2
			a.m_c[0] // g3
		);

}
inline spinor dual(const spinor &a)
{
	return spinor(spinor::coord_scalar_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3_g0g1g2g3,
			a.m_c[7], // scalar
			a.m_c[6], // g0_g1
			-a.m_c[5], // g0_g2
			a.m_c[4], // g0_g3
			-a.m_c[3], // g1_g2
			a.m_c[2], // g1_g3
			-a.m_c[1], // g2_g3
			-a.m_c[0] // g0_g1_g2_g3
		);

}
inline mv3 negate(const mv3 &a)
{
	return mv3(mv3::coord_scalar_g1_g2_g3_g1g2_g1g3_g2g3_g1g2g3,
			-a.m_c[0], // scalar
			-a.m_c[1], // g1
			-a.m_c[2], // g2
			-a.m_c[3], // g3
			-a.m_c[4], // g1_g2
			-a.m_c[5], // g1_g3
			-a.m_c[6], // g2_g3
			-a.m_c[7] // g1_g2_g3
		);

}
inline vector negate(const vector &a)
{
	return vector(vector::coord_g0_g1_g2_g3,
			-a.m_c[0], // g0
			-a.m_c[1], // g1
			-a.m_c[2], // g2
			-a.m_c[3] // g3
		);

}
inline vector3 negate(const vector3 &a)
{
	return vector3(vector3::coord_g1_g2_g3,
			-a.m_c[0], // g1
			-a.m_c[1], // g2
			-a.m_c[2] // g3
		);

}
inline bivector negate(const bivector &a)
{
	return bivector(bivector::coord_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3,
			-a.m_c[0], // g0_g1
			-a.m_c[1], // g0_g2
			-a.m_c[2], // g0_g3
			-a.m_c[3], // g1_g2
			-a.m_c[4], // g1_g3
			-a.m_c[5] // g2_g3
		);

}
inline bivector3 negate(const bivector3 &a)
{
	return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
			-a.m_c[0], // g1_g2
			-a.m_c[1], // g1_g3
			-a.m_c[2] // g2_g3
		);

}
inline pseudovector negate(const pseudovector &a)
{
	return pseudovector(pseudovector::coord_g0g1g2_g0g1g3_g0g2g3_g1g2g3,
			-a.m_c[0], // g0_g1_g2
			-a.m_c[1], // g0_g1_g3
			-a.m_c[2], // g0_g2_g3
			-a.m_c[3] // g1_g2_g3
		);

}
inline spinor negate(const spinor &a)
{
	return spinor(spinor::coord_scalar_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3_g0g1g2g3,
			-a.m_c[0], // scalar
			-a.m_c[1], // g0_g1
			-a.m_c[2], // g0_g2
			-a.m_c[3], // g0_g3
			-a.m_c[4], // g1_g2
			-a.m_c[5], // g1_g3
			-a.m_c[6], // g2_g3
			-a.m_c[7] // g0_g1_g2_g3
		);

}
inline spinor3 negate(const spinor3 &a)
{
	return spinor3(spinor3::coord_scalar_g1g2_g1g3_g2g3,
			-a.m_c[0], // scalar
			-a.m_c[1], // g1_g2
			-a.m_c[2], // g1_g3
			-a.m_c[3] // g2_g3
		);

}
inline mv3 reverse(const mv3 &a)
{
	return mv3(mv3::coord_scalar_g1_g2_g3_g1g2_g1g3_g2g3_g1g2g3,
			a.m_c[0], // scalar
			a.m_c[1], // g1
			a.m_c[2], // g2
			a.m_c[3], // g3
			-a.m_c[4], // g1_g2
			-a.m_c[5], // g1_g3
			-a.m_c[6], // g2_g3
			-a.m_c[7] // g1_g2_g3
		);

}
inline vector reverse(const vector &a)
{
	return vector(vector::coord_g0_g1_g2_g3,
			a.m_c[0], // g0
			a.m_c[1], // g1
			a.m_c[2], // g2
			a.m_c[3] // g3
		);

}
inline vector3 reverse(const vector3 &a)
{
	return vector3(vector3::coord_g1_g2_g3,
			a.m_c[0], // g1
			a.m_c[1], // g2
			a.m_c[2] // g3
		);

}
inline bivector reverse(const bivector &a)
{
	return bivector(bivector::coord_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3,
			-a.m_c[0], // g0_g1
			-a.m_c[1], // g0_g2
			-a.m_c[2], // g0_g3
			-a.m_c[3], // g1_g2
			-a.m_c[4], // g1_g3
			-a.m_c[5] // g2_g3
		);

}
inline bivector3 reverse(const bivector3 &a)
{
	return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
			-a.m_c[0], // g1_g2
			-a.m_c[1], // g1_g3
			-a.m_c[2] // g2_g3
		);

}
inline pseudovector reverse(const pseudovector &a)
{
	return pseudovector(pseudovector::coord_g0g1g2_g0g1g3_g0g2g3_g1g2g3,
			-a.m_c[0], // g0_g1_g2
			-a.m_c[1], // g0_g1_g3
			-a.m_c[2], // g0_g2_g3
			-a.m_c[3] // g1_g2_g3
		);

}
inline spinor reverse(const spinor &a)
{
	return spinor(spinor::coord_scalar_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3_g0g1g2g3,
			a.m_c[0], // scalar
			-a.m_c[1], // g0_g1
			-a.m_c[2], // g0_g2
			-a.m_c[3], // g0_g3
			-a.m_c[4], // g1_g2
			-a.m_c[5], // g1_g3
			-a.m_c[6], // g2_g3
			a.m_c[7] // g0_g1_g2_g3
		);

}
inline spinor3 reverse(const spinor3 &a)
{
	return spinor3(spinor3::coord_scalar_g1g2_g1g3_g2g3,
			a.m_c[0], // scalar
			-a.m_c[1], // g1_g2
			-a.m_c[2], // g1_g3
			-a.m_c[3] // g2_g3
		);

}
inline mv3 cliffordConjugate(const mv3 &a)
{
	return mv3(mv3::coord_scalar_g1_g2_g3_g1g2_g1g3_g2g3_g1g2g3,
			a.m_c[0], // scalar
			-a.m_c[1], // g1
			-a.m_c[2], // g2
			-a.m_c[3], // g3
			-a.m_c[4], // g1_g2
			-a.m_c[5], // g1_g3
			-a.m_c[6], // g2_g3
			a.m_c[7] // g1_g2_g3
		);

}
inline vector cliffordConjugate(const vector &a)
{
	return vector(vector::coord_g0_g1_g2_g3,
			-a.m_c[0], // g0
			-a.m_c[1], // g1
			-a.m_c[2], // g2
			-a.m_c[3] // g3
		);

}
inline vector3 cliffordConjugate(const vector3 &a)
{
	return vector3(vector3::coord_g1_g2_g3,
			-a.m_c[0], // g1
			-a.m_c[1], // g2
			-a.m_c[2] // g3
		);

}
inline bivector cliffordConjugate(const bivector &a)
{
	return bivector(bivector::coord_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3,
			-a.m_c[0], // g0_g1
			-a.m_c[1], // g0_g2
			-a.m_c[2], // g0_g3
			-a.m_c[3], // g1_g2
			-a.m_c[4], // g1_g3
			-a.m_c[5] // g2_g3
		);

}
inline bivector3 cliffordConjugate(const bivector3 &a)
{
	return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
			-a.m_c[0], // g1_g2
			-a.m_c[1], // g1_g3
			-a.m_c[2] // g2_g3
		);

}
inline pseudovector cliffordConjugate(const pseudovector &a)
{
	return pseudovector(pseudovector::coord_g0g1g2_g0g1g3_g0g2g3_g1g2g3,
			a.m_c[0], // g0_g1_g2
			a.m_c[1], // g0_g1_g3
			a.m_c[2], // g0_g2_g3
			a.m_c[3] // g1_g2_g3
		);

}
inline spinor cliffordConjugate(const spinor &a)
{
	return spinor(spinor::coord_scalar_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3_g0g1g2g3,
			a.m_c[0], // scalar
			-a.m_c[1], // g0_g1
			-a.m_c[2], // g0_g2
			-a.m_c[3], // g0_g3
			-a.m_c[4], // g1_g2
			-a.m_c[5], // g1_g3
			-a.m_c[6], // g2_g3
			a.m_c[7] // g0_g1_g2_g3
		);

}
inline spinor3 cliffordConjugate(const spinor3 &a)
{
	return spinor3(spinor3::coord_scalar_g1g2_g1g3_g2g3,
			a.m_c[0], // scalar
			-a.m_c[1], // g1_g2
			-a.m_c[2], // g1_g3
			-a.m_c[3] // g2_g3
		);

}
inline mv3 gradeInvolution(const mv3 &a)
{
	return mv3(mv3::coord_scalar_g1_g2_g3_g1g2_g1g3_g2g3_g1g2g3,
			a.m_c[0], // scalar
			-a.m_c[1], // g1
			-a.m_c[2], // g2
			-a.m_c[3], // g3
			a.m_c[4], // g1_g2
			a.m_c[5], // g1_g3
			a.m_c[6], // g2_g3
			-a.m_c[7] // g1_g2_g3
		);

}
inline vector gradeInvolution(const vector &a)
{
	return vector(vector::coord_g0_g1_g2_g3,
			-a.m_c[0], // g0
			-a.m_c[1], // g1
			-a.m_c[2], // g2
			-a.m_c[3] // g3
		);

}
inline vector3 gradeInvolution(const vector3 &a)
{
	return vector3(vector3::coord_g1_g2_g3,
			-a.m_c[0], // g1
			-a.m_c[1], // g2
			-a.m_c[2] // g3
		);

}
inline bivector gradeInvolution(const bivector &a)
{
	return bivector(bivector::coord_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3,
			a.m_c[0], // g0_g1
			a.m_c[1], // g0_g2
			a.m_c[2], // g0_g3
			a.m_c[3], // g1_g2
			a.m_c[4], // g1_g3
			a.m_c[5] // g2_g3
		);

}
inline bivector3 gradeInvolution(const bivector3 &a)
{
	return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
			a.m_c[0], // g1_g2
			a.m_c[1], // g1_g3
			a.m_c[2] // g2_g3
		);

}
inline pseudovector gradeInvolution(const pseudovector &a)
{
	return pseudovector(pseudovector::coord_g0g1g2_g0g1g3_g0g2g3_g1g2g3,
			-a.m_c[0], // g0_g1_g2
			-a.m_c[1], // g0_g1_g3
			-a.m_c[2], // g0_g2_g3
			-a.m_c[3] // g1_g2_g3
		);

}
inline spinor gradeInvolution(const spinor &a)
{
	return spinor(spinor::coord_scalar_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3_g0g1g2g3,
			a.m_c[0], // scalar
			a.m_c[1], // g0_g1
			a.m_c[2], // g0_g2
			a.m_c[3], // g0_g3
			a.m_c[4], // g1_g2
			a.m_c[5], // g1_g3
			a.m_c[6], // g2_g3
			a.m_c[7] // g0_g1_g2_g3
		);

}
inline spinor3 gradeInvolution(const spinor3 &a)
{
	return spinor3(spinor3::coord_scalar_g1g2_g1g3_g2g3,
			a.m_c[0], // scalar
			a.m_c[1], // g1_g2
			a.m_c[2], // g1_g3
			a.m_c[3] // g2_g3
		);

}
inline double norm_returns_scalar(const mv &a) {
	return norm(a);
}
inline double norm(const mv3 &a)
{
	return ::fabs(::sqrt(::fabs((a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]-a.m_c[3]*a.m_c[3]+a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5]+a.m_c[6]*a.m_c[6]-a.m_c[7]*a.m_c[7]))));

}
inline double norm_returns_scalar(const mv3 &a) {
	return norm(a);
}
inline double norm(const vector &a)
{
	return ::fabs(::sqrt(::fabs((a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]-a.m_c[3]*a.m_c[3]))));

}
inline double norm_returns_scalar(const vector &a) {
	return norm(a);
}
inline double norm(const vector3 &a)
{
	return ::fabs(::sqrt(::fabs((-a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]))));

}
inline double norm_returns_scalar(const vector3 &a) {
	return norm(a);
}
inline double norm(const bivector &a)
{
	return ::fabs(::sqrt(::fabs((-a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]+a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5]))));

}
inline double norm_returns_scalar(const bivector &a) {
	return norm(a);
}
inline double norm(const bivector3 &a)
{
	return ::fabs(::sqrt(::fabs((a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]))));

}
inline double norm_returns_scalar(const bivector3 &a) {
	return norm(a);
}
inline double norm(const pseudovector &a)
{
	return ::fabs(::sqrt(::fabs((a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]-a.m_c[3]*a.m_c[3]))));

}
inline double norm_returns_scalar(const pseudovector &a) {
	return norm(a);
}
inline double norm(const spinor &a)
{
	return ::fabs(::sqrt(::fabs((a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]-a.m_c[3]*a.m_c[3]+a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5]+a.m_c[6]*a.m_c[6]-a.m_c[7]*a.m_c[7]))));

}
inline double norm_returns_scalar(const spinor &a) {
	return norm(a);
}
inline double norm(const spinor3 &a)
{
	return ::fabs(::sqrt(::fabs((a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]))));

}
inline double norm_returns_scalar(const spinor3 &a) {
	return norm(a);
}
inline double norm2_returns_scalar(const mv &a) {
	return norm2(a);
}
inline double norm2(const mv3 &a)
{
	return (a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]-a.m_c[3]*a.m_c[3]+a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5]+a.m_c[6]*a.m_c[6]-a.m_c[7]*a.m_c[7]);

}
inline double norm2_returns_scalar(const mv3 &a) {
	return norm2(a);
}
inline double norm2(const vector &a)
{
	return (a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]-a.m_c[3]*a.m_c[3]);

}
inline double norm2_returns_scalar(const vector &a) {
	return norm2(a);
}
inline double norm2(const vector3 &a)
{
	return (-a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]);

}
inline double norm2_returns_scalar(const vector3 &a) {
	return norm2(a);
}
inline double norm2(const bivector &a)
{
	return (-a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]+a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5]);

}
inline double norm2_returns_scalar(const bivector &a) {
	return norm2(a);
}
inline double norm2(const bivector3 &a)
{
	return (a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]);

}
inline double norm2_returns_scalar(const bivector3 &a) {
	return norm2(a);
}
inline double norm2(const pseudovector &a)
{
	return (a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]-a.m_c[3]*a.m_c[3]);

}
inline double norm2_returns_scalar(const pseudovector &a) {
	return norm2(a);
}
inline double norm2(const spinor &a)
{
	return (a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]-a.m_c[3]*a.m_c[3]+a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5]+a.m_c[6]*a.m_c[6]-a.m_c[7]*a.m_c[7]);

}
inline double norm2_returns_scalar(const spinor &a) {
	return norm2(a);
}
inline double norm2(const spinor3 &a)
{
	return (a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]);

}
inline double norm2_returns_scalar(const spinor3 &a) {
	return norm2(a);
}
inline double norm2_euclidean_returns_scalar(const mv &a) {
	return norm2_euclidean(a);
}
inline mv3 unit(const mv3 &a)
{
	double _n_ = ::sqrt(::fabs((a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]-a.m_c[3]*a.m_c[3]+a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5]+a.m_c[6]*a.m_c[6]-a.m_c[7]*a.m_c[7])));

	return mv3(mv3::coord_scalar_g1_g2_g3_g1g2_g1g3_g2g3_g1g2g3,
			a.m_c[0]/((_n_)), // scalar
			a.m_c[1]/((_n_)), // g1
			a.m_c[2]/((_n_)), // g2
			a.m_c[3]/((_n_)), // g3
			a.m_c[4]/((_n_)), // g1_g2
			a.m_c[5]/((_n_)), // g1_g3
			a.m_c[6]/((_n_)), // g2_g3
			a.m_c[7]/((_n_)) // g1_g2_g3
		);
}
inline vector unit(const vector &a)
{
	double _n_ = ::sqrt(::fabs((a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]-a.m_c[3]*a.m_c[3])));

	return vector(vector::coord_g0_g1_g2_g3,
			a.m_c[0]/((_n_)), // g0
			a.m_c[1]/((_n_)), // g1
			a.m_c[2]/((_n_)), // g2
			a.m_c[3]/((_n_)) // g3
		);
}
inline vector3 unit(const vector3 &a)
{
	double _n_ = ::sqrt(::fabs((-a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2])));

	return vector3(vector3::coord_g1_g2_g3,
			a.m_c[0]/((_n_)), // g1
			a.m_c[1]/((_n_)), // g2
			a.m_c[2]/((_n_)) // g3
		);
}
inline bivector unit(const bivector &a)
{
	double _n_ = ::sqrt(::fabs((-a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]+a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5])));

	return bivector(bivector::coord_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3,
			a.m_c[0]/((_n_)), // g0_g1
			a.m_c[1]/((_n_)), // g0_g2
			a.m_c[2]/((_n_)), // g0_g3
			a.m_c[3]/((_n_)), // g1_g2
			a.m_c[4]/((_n_)), // g1_g3
			a.m_c[5]/((_n_)) // g2_g3
		);
}
inline bivector3 unit(const bivector3 &a)
{
	double _n_ = ::sqrt(::fabs((a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2])));

	return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
			a.m_c[0]/((_n_)), // g1_g2
			a.m_c[1]/((_n_)), // g1_g3
			a.m_c[2]/((_n_)) // g2_g3
		);
}
inline pseudovector unit(const pseudovector &a)
{
	double _n_ = ::sqrt(::fabs((a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]-a.m_c[3]*a.m_c[3])));

	return pseudovector(pseudovector::coord_g0g1g2_g0g1g3_g0g2g3_g1g2g3,
			a.m_c[0]/((_n_)), // g0_g1_g2
			a.m_c[1]/((_n_)), // g0_g1_g3
			a.m_c[2]/((_n_)), // g0_g2_g3
			a.m_c[3]/((_n_)) // g1_g2_g3
		);
}
inline spinor unit(const spinor &a)
{
	double _n_ = ::sqrt(::fabs((a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]-a.m_c[3]*a.m_c[3]+a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5]+a.m_c[6]*a.m_c[6]-a.m_c[7]*a.m_c[7])));

	return spinor(spinor::coord_scalar_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3_g0g1g2g3,
			a.m_c[0]/((_n_)), // scalar
			a.m_c[1]/((_n_)), // g0_g1
			a.m_c[2]/((_n_)), // g0_g2
			a.m_c[3]/((_n_)), // g0_g3
			a.m_c[4]/((_n_)), // g1_g2
			a.m_c[5]/((_n_)), // g1_g3
			a.m_c[6]/((_n_)), // g2_g3
			a.m_c[7]/((_n_)) // g0_g1_g2_g3
		);
}
inline spinor3 unit(const spinor3 &a)
{
	double _n_ = ::sqrt(::fabs((a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3])));

	return spinor3(spinor3::coord_scalar_g1g2_g1g3_g2g3,
			a.m_c[0]/((_n_)), // scalar
			a.m_c[1]/((_n_)), // g1_g2
			a.m_c[2]/((_n_)), // g1_g3
			a.m_c[3]/((_n_)) // g2_g3
		);
}
inline spinor3 versorInverse(const spinor3 &a)
{
	double _n2_ = (a.m_c[0]*a.m_c[0]+a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]);

	return spinor3(spinor3::coord_scalar_g1g2_g1g3_g2g3,
			a.m_c[0]/((_n2_)), // scalar
			-a.m_c[1]/((_n2_)), // g1_g2
			-a.m_c[2]/((_n2_)), // g1_g3
			-a.m_c[3]/((_n2_)) // g2_g3
		);
}
inline spinor versorInverse(const spinor &a)
{
	double _n2_ = (a.m_c[0]*a.m_c[0]-a.m_c[1]*a.m_c[1]-a.m_c[2]*a.m_c[2]-a.m_c[3]*a.m_c[3]+a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5]+a.m_c[6]*a.m_c[6]-a.m_c[7]*a.m_c[7]);

	return spinor(spinor::coord_scalar_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3_g0g1g2g3,
			a.m_c[0]/((_n2_)), // scalar
			-a.m_c[1]/((_n2_)), // g0_g1
			-a.m_c[2]/((_n2_)), // g0_g2
			-a.m_c[3]/((_n2_)), // g0_g3
			-a.m_c[4]/((_n2_)), // g1_g2
			-a.m_c[5]/((_n2_)), // g1_g3
			-a.m_c[6]/((_n2_)), // g2_g3
			a.m_c[7]/((_n2_)) // g0_g1_g2_g3
		);
}
inline spinor3 sas(const spinor3 &a, const double b, const double c)
{
	return spinor3(spinor3::coord_scalar_g1g2_g1g3_g2g3,
			(a.m_c[0]*b+c), // scalar
			a.m_c[1]*b, // g1_g2
			a.m_c[2]*b, // g1_g3
			a.m_c[3]*b // g2_g3
		);
}
inline spinor sas(const spinor &a, const double b, const double c)
{
	return spinor(spinor::coord_scalar_g0g1_g0g2_g0g3_g1g2_g1g3_g2g3_g0g1g2g3,
			(a.m_c[0]*b+c), // scalar
			a.m_c[1]*b, // g0_g1
			a.m_c[2]*b, // g0_g2
			a.m_c[3]*b, // g0_g3
			a.m_c[4]*b, // g1_g2
			a.m_c[5]*b, // g1_g3
			a.m_c[6]*b, // g2_g3
			a.m_c[7]*b // g0_g1_g2_g3
		);
}
inline bivector3 log(const mv3 &a)
{
	double _g2norm2_ = (a.m_c[4]*a.m_c[4]+a.m_c[5]*a.m_c[5]+a.m_c[6]*a.m_c[6]);

	double _scalarPart_ = a.m_c[0];

	if (_g2norm2_ <= 0.0) {
		if (_scalarPart_ < 0.0) {
			return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
					3.1415926535897931, // g1_g2
					0.0, // g1_g3
					0.0 // g2_g3
				);
		}
		else {
			return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
					0.0, // g1_g2
					0.0, // g1_g3
					0.0 // g2_g3
				);
		}
	}
	else {
		double _g2norm_ = ::sqrt(_g2norm2_);

		double _mul_ = (::atan2(_g2norm_, _scalarPart_))/(_g2norm_);

		return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
				_mul_*a.m_c[4], // g1_g2
				_mul_*a.m_c[5], // g1_g3
				_mul_*a.m_c[6] // g2_g3
			);
	}
}
inline bivector3 log(const spinor3 &a)
{
	double _g2norm2_ = (a.m_c[1]*a.m_c[1]+a.m_c[2]*a.m_c[2]+a.m_c[3]*a.m_c[3]);

	double _scalarPart_ = a.m_c[0];

	if (_g2norm2_ <= 0.0) {
		if (_scalarPart_ < 0.0) {
			return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
					3.1415926535897931, // g1_g2
					0.0, // g1_g3
					0.0 // g2_g3
				);
		}
		else {
			return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
					0.0, // g1_g2
					0.0, // g1_g3
					0.0 // g2_g3
				);
		}
	}
	else {
		double _g2norm_ = ::sqrt(_g2norm2_);

		double _mul_ = (::atan2(_g2norm_, _scalarPart_))/(_g2norm_);

		return bivector3(bivector3::coord_g1g2_g1g3_g2g3,
				_mul_*a.m_c[1], // g1_g2
				_mul_*a.m_c[2], // g1_g3
				_mul_*a.m_c[3] // g2_g3
			);
	}
}
inline vector applyVersor(const spinor &R, const vector &v)
{
	double _n2_ = (R.m_c[0]*R.m_c[0]-R.m_c[1]*R.m_c[1]-R.m_c[2]*R.m_c[2]-R.m_c[3]*R.m_c[3]+R.m_c[4]*R.m_c[4]+R.m_c[5]*R.m_c[5]+R.m_c[6]*R.m_c[6]-R.m_c[7]*R.m_c[7]);

	return vector(vector::coord_g0_g1_g2_g3,
			((R.m_c[0]*R.m_c[0]*v.m_c[0]+-2.0*R.m_c[0]*R.m_c[1]*v.m_c[1]+-2.0*R.m_c[0]*R.m_c[2]*v.m_c[2]+-2.0*R.m_c[0]*R.m_c[3]*v.m_c[3]+R.m_c[1]*R.m_c[1]*v.m_c[0]+2.0*R.m_c[1]*R.m_c[4]*v.m_c[2]+2.0*R.m_c[1]*R.m_c[5]*v.m_c[3]+R.m_c[2]*R.m_c[2]*v.m_c[0]+-2.0*R.m_c[2]*R.m_c[4]*v.m_c[1]+2.0*R.m_c[2]*R.m_c[6]*v.m_c[3]+R.m_c[3]*R.m_c[3]*v.m_c[0]+-2.0*R.m_c[3]*R.m_c[5]*v.m_c[1]+-2.0*R.m_c[3]*R.m_c[6]*v.m_c[2]+R.m_c[4]*R.m_c[4]*v.m_c[0]+-2.0*R.m_c[4]*R.m_c[7]*v.m_c[3]+R.m_c[5]*R.m_c[5]*v.m_c[0]+2.0*R.m_c[5]*R.m_c[7]*v.m_c[2]+R.m_c[6]*R.m_c[6]*v.m_c[0]+-2.0*R.m_c[6]*R.m_c[7]*v.m_c[1]+R.m_c[7]*R.m_c[7]*v.m_c[0]))/(_n2_), // g0
			((R.m_c[0]*R.m_c[0]*v.m_c[1]+-2.0*R.m_c[0]*R.m_c[1]*v.m_c[0]+-2.0*R.m_c[0]*R.m_c[4]*v.m_c[2]+-2.0*R.m_c[0]*R.m_c[5]*v.m_c[3]+R.m_c[1]*R.m_c[1]*v.m_c[1]+2.0*R.m_c[1]*R.m_c[2]*v.m_c[2]+2.0*R.m_c[1]*R.m_c[3]*v.m_c[3]-R.m_c[2]*R.m_c[2]*v.m_c[1]+2.0*R.m_c[2]*R.m_c[4]*v.m_c[0]+-2.0*R.m_c[2]*R.m_c[7]*v.m_c[3]-R.m_c[3]*R.m_c[3]*v.m_c[1]+2.0*R.m_c[3]*R.m_c[5]*v.m_c[0]+2.0*R.m_c[3]*R.m_c[7]*v.m_c[2]-R.m_c[4]*R.m_c[4]*v.m_c[1]+2.0*R.m_c[4]*R.m_c[6]*v.m_c[3]-R.m_c[5]*R.m_c[5]*v.m_c[1]+-2.0*R.m_c[5]*R.m_c[6]*v.m_c[2]+R.m_c[6]*R.m_c[6]*v.m_c[1]+-2.0*R.m_c[6]*R.m_c[7]*v.m_c[0]+R.m_c[7]*R.m_c[7]*v.m_c[1]))/(_n2_), // g1
			((R.m_c[0]*R.m_c[0]*v.m_c[2]+-2.0*R.m_c[0]*R.m_c[2]*v.m_c[0]+2.0*R.m_c[0]*R.m_c[4]*v.m_c[1]+-2.0*R.m_c[0]*R.m_c[6]*v.m_c[3]-R.m_c[1]*R.m_c[1]*v.m_c[2]+2.0*R.m_c[1]*R.m_c[2]*v.m_c[1]+-2.0*R.m_c[1]*R.m_c[4]*v.m_c[0]+2.0*R.m_c[1]*R.m_c[7]*v.m_c[3]+R.m_c[2]*R.m_c[2]*v.m_c[2]+2.0*R.m_c[2]*R.m_c[3]*v.m_c[3]-R.m_c[3]*R.m_c[3]*v.m_c[2]+2.0*R.m_c[3]*R.m_c[6]*v.m_c[0]+-2.0*R.m_c[3]*R.m_c[7]*v.m_c[1]-R.m_c[4]*R.m_c[4]*v.m_c[2]+-2.0*R.m_c[4]*R.m_c[5]*v.m_c[3]+R.m_c[5]*R.m_c[5]*v.m_c[2]+-2.0*R.m_c[5]*R.m_c[6]*v.m_c[1]+2.0*R.m_c[5]*R.m_c[7]*v.m_c[0]-R.m_c[6]*R.m_c[6]*v.m_c[2]+R.m_c[7]*R.m_c[7]*v.m_c[2]))/(_n2_), // g2
			((R.m_c[0]*R.m_c[0]*v.m_c[3]+-2.0*R.m_c[0]*R.m_c[3]*v.m_c[0]+2.0*R.m_c[0]*R.m_c[5]*v.m_c[1]+2.0*R.m_c[0]*R.m_c[6]*v.m_c[2]-R.m_c[1]*R.m_c[1]*v.m_c[3]+2.0*R.m_c[1]*R.m_c[3]*v.m_c[1]+-2.0*R.m_c[1]*R.m_c[5]*v.m_c[0]+-2.0*R.m_c[1]*R.m_c[7]*v.m_c[2]-R.m_c[2]*R.m_c[2]*v.m_c[3]+2.0*R.m_c[2]*R.m_c[3]*v.m_c[2]+-2.0*R.m_c[2]*R.m_c[6]*v.m_c[0]+2.0*R.m_c[2]*R.m_c[7]*v.m_c[1]+R.m_c[3]*R.m_c[3]*v.m_c[3]+R.m_c[4]*R.m_c[4]*v.m_c[3]+-2.0*R.m_c[4]*R.m_c[5]*v.m_c[2]+2.0*R.m_c[4]*R.m_c[6]*v.m_c[1]+-2.0*R.m_c[4]*R.m_c[7]*v.m_c[0]-R.m_c[5]*R.m_c[5]*v.m_c[3]-R.m_c[6]*R.m_c[6]*v.m_c[3]+R.m_c[7]*R.m_c[7]*v.m_c[3]))/(_n2_) // g3
		);
}
inline vector3 applyUnitVersor(const spinor3 &R, const vector3 &v)
{
	return vector3(vector3::coord_g1_g2_g3,
			(R.m_c[0]*R.m_c[0]*v.m_c[0]+-2.0*R.m_c[0]*R.m_c[1]*v.m_c[1]+-2.0*R.m_c[0]*R.m_c[2]*v.m_c[2]-R.m_c[1]*R.m_c[1]*v.m_c[0]+2.0*R.m_c[1]*R.m_c[3]*v.m_c[2]-R.m_c[2]*R.m_c[2]*v.m_c[0]+-2.0*R.m_c[2]*R.m_c[3]*v.m_c[1]+R.m_c[3]*R.m_c[3]*v.m_c[0]), // g1
			(R.m_c[0]*R.m_c[0]*v.m_c[1]+2.0*R.m_c[0]*R.m_c[1]*v.m_c[0]+-2.0*R.m_c[0]*R.m_c[3]*v.m_c[2]-R.m_c[1]*R.m_c[1]*v.m_c[1]+-2.0*R.m_c[1]*R.m_c[2]*v.m_c[2]+R.m_c[2]*R.m_c[2]*v.m_c[1]+-2.0*R.m_c[2]*R.m_c[3]*v.m_c[0]-R.m_c[3]*R.m_c[3]*v.m_c[1]), // g2
			(R.m_c[0]*R.m_c[0]*v.m_c[2]+2.0*R.m_c[0]*R.m_c[2]*v.m_c[0]+2.0*R.m_c[0]*R.m_c[3]*v.m_c[1]+R.m_c[1]*R.m_c[1]*v.m_c[2]+-2.0*R.m_c[1]*R.m_c[2]*v.m_c[1]+2.0*R.m_c[1]*R.m_c[3]*v.m_c[0]-R.m_c[2]*R.m_c[2]*v.m_c[2]-R.m_c[3]*R.m_c[3]*v.m_c[2]) // g3
		);
}


/** structure used by custom parser */
struct m4staParseMultivectorData {
	/** the parsed value */
	mv value;
	/** this string will contain an error message when error is true */
	char message[256];
};

/** 
Parses 'str' (output of toString_mv()) and stores result in 'val' 
Throws std::string on error.
*/
mv parse(const std::string &str);

/** 
Parses 'str' (output of toString_mv()) and stores result in 'data'. 
'strSourceName' is the name of the source of 'str' (for example, a filename).
It is used for error messages.

	Returns true when 'str' parsed correctly.
Otherwise a lexer or parser error occured and you can check 
the errors in 'data->message'.
*/
bool parseEx(struct m4staParseMultivectorData &data, const std::string &str, const std::string &strSourceName);
} // end of namespace m4sta
#endif /* _M4STA_H_ */
